{"ast":null,"code":"import { useVisuallyHidden } from \"@react-aria/visually-hidden\";\nimport { useMenuTrigger } from \"@react-aria/menu\";\nimport { useLabel } from \"@react-aria/label\";\nimport { useCollator } from \"@react-aria/i18n\";\nimport { setInteractionModality, useInteractionModality } from \"@react-aria/interactions\";\nimport { ListKeyboardDelegate, useTypeSelect } from \"@react-aria/selection\";\nimport _react, { useMemo } from \"react\";\nimport { filterDOMProps, mergeProps, useId } from \"@react-aria/utils\";\nimport _babelRuntimeHelpersEsmExtends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * Provides the behavior and accessibility implementation for a select component.\n * A select displays a collapsible list of options and allows a user to select one of them.\n * @param props - Props for the select.\n * @param state - State for the select, as returned by `useListState`.\n */\n\nexport function useSelect(props, state, ref) {\n  let {\n    keyboardDelegate\n  } = props; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n\n  let collator = useCollator({\n    usage: 'search',\n    sensitivity: 'base'\n  });\n  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(state.collection, state.disabledKeys, null, collator), [keyboardDelegate, state.collection, state.disabledKeys, collator]);\n  let {\n    menuTriggerProps,\n    menuProps\n  } = useMenuTrigger({\n    type: 'listbox'\n  }, state, ref);\n  let {\n    typeSelectProps\n  } = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: state.selectionManager,\n\n    onTypeSelect(key) {\n      state.setSelectedKey(key);\n    }\n\n  });\n  let {\n    labelProps,\n    fieldProps\n  } = useLabel(_babelRuntimeHelpersEsmExtends({}, props, {\n    labelElementType: 'span'\n  }));\n  let domProps = filterDOMProps(props, {\n    labelable: true\n  });\n  let triggerProps = mergeProps(mergeProps(menuTriggerProps, fieldProps), typeSelectProps);\n  let valueId = useId();\n  return {\n    labelProps: _babelRuntimeHelpersEsmExtends({}, labelProps, {\n      onClick: () => {\n        if (!props.isDisabled) {\n          ref.current.focus(); // Show the focus ring so the user knows where focus went\n\n          setInteractionModality('keyboard');\n        }\n      }\n    }),\n    triggerProps: mergeProps(domProps, _babelRuntimeHelpersEsmExtends({}, triggerProps, {\n      'aria-labelledby': [triggerProps['aria-labelledby'], triggerProps['aria-label'] && !triggerProps['aria-labelledby'] ? triggerProps.id : null, valueId].filter(Boolean).join(' '),\n\n      onFocus() {\n        state.setFocused(true);\n      },\n\n      onBlur() {\n        state.setFocused(false);\n      }\n\n    })),\n    valueProps: {\n      id: valueId\n    },\n    menuProps: _babelRuntimeHelpersEsmExtends({}, menuProps, {\n      'aria-labelledby': [fieldProps['aria-labelledby'], triggerProps['aria-label'] && !fieldProps['aria-labelledby'] ? triggerProps.id : null].filter(Boolean).join(' ')\n    })\n  };\n}\n/**\n * Provides the behavior and accessibility implementation for a hidden `<select>` element, which\n * can be used in combination with `useSelect` to support browser form autofill, mobile form\n * navigation, and native HTML form submission.\n */\n\nexport function useHiddenSelect(props, state, triggerRef) {\n  var _state$selectedKey;\n\n  let {\n    name,\n    isDisabled\n  } = props;\n  let modality = useInteractionModality();\n  let {\n    visuallyHiddenProps\n  } = useVisuallyHidden(); // In Safari, the <select> cannot have `display: none` or `hidden` for autofill to work.\n  // In Firefox, there must be a <label> to identify the <select> whereas other browsers\n  // seem to identify it just by surrounding text.\n  // The solution is to use <VisuallyHidden> to hide the elements, which clips the elements to a\n  // 1px rectangle. In addition, we hide from screen readers with aria-hidden, and make the <select>\n  // non tabbable with tabIndex={-1}.\n  //\n  // In mobile browsers, there are next/previous buttons above the software keyboard for navigating\n  // between fields in a form. These only support native form inputs that are tabbable. In order to\n  // support those, an additional hidden input is used to marshall focus to the button. It is tabbable\n  // except when the button is focused, so that shift tab works properly to go to the actual previous\n  // input in the form. Using the <select> for this also works, but Safari on iOS briefly flashes\n  // the native menu on focus, so this isn't ideal. A font-size of 16px or greater is required to\n  // prevent Safari from zooming in on the input when it is focused.\n  //\n  // If the current interaction modality is null, then the user hasn't interacted with the page yet.\n  // In this case, we set the tabIndex to -1 on the input element so that automated accessibility\n  // checkers don't throw false-positives about focusable elements inside an aria-hidden parent.\n\n  return {\n    containerProps: _babelRuntimeHelpersEsmExtends({}, visuallyHiddenProps, {\n      'aria-hidden': true\n    }),\n    inputProps: {\n      type: 'text',\n      tabIndex: modality == null || state.isFocused || state.isOpen ? -1 : 0,\n      style: {\n        fontSize: 16\n      },\n      onFocus: () => triggerRef.current.focus(),\n      disabled: isDisabled\n    },\n    selectProps: {\n      tabIndex: -1,\n      disabled: isDisabled,\n      name,\n      size: state.collection.size,\n      value: (_state$selectedKey = state.selectedKey) != null ? _state$selectedKey : '',\n      onChange: e => state.setSelectedKey(e.target.value)\n    }\n  };\n}\n/**\n * Renders a hidden native `<select>` element, which can be used to support browser\n * form autofill, mobile form navigation, and native form submission.\n */\n\nexport function HiddenSelect(props) {\n  let {\n    state,\n    triggerRef,\n    label,\n    name,\n    isDisabled\n  } = props;\n  let {\n    containerProps,\n    inputProps,\n    selectProps\n  } = useHiddenSelect(props, state, triggerRef); // If used in a <form>, use a hidden input so the value can be submitted to a server.\n  // If the collection isn't too big, use a hidden <select> element for this so that browser\n  // autofill will work. Otherwise, use an <input type=\"hidden\">.\n\n  if (state.collection.size <= 300) {\n    return /*#__PURE__*/_react.createElement(\"div\", containerProps, /*#__PURE__*/_react.createElement(\"input\", inputProps), /*#__PURE__*/_react.createElement(\"label\", null, label, /*#__PURE__*/_react.createElement(\"select\", selectProps, [...state.collection.getKeys()].map(key => {\n      let item = state.collection.getItem(key);\n\n      if (item.type === 'item') {\n        return /*#__PURE__*/_react.createElement(\"option\", {\n          key: item.key,\n          value: item.key\n        }, item.textValue);\n      }\n    }))));\n  } else if (name) {\n    return /*#__PURE__*/_react.createElement(\"input\", {\n      type: \"hidden\",\n      name: name,\n      disabled: isDisabled,\n      value: state.selectedKey\n    });\n  }\n\n  return null;\n}","map":{"version":3,"sources":["packages/@react-aria/select/src/useSelect.ts","packages/@react-aria/select/src/HiddenSelect.tsx"],"names":["keyboardDelegate","collator","useCollator","usage","sensitivity","delegate","useMemo","state","menuProps","useMenuTrigger","type","typeSelectProps","useTypeSelect","selectionManager","onTypeSelect","fieldProps","useLabel","labelElementType","domProps","filterDOMProps","labelable","triggerProps","mergeProps","valueId","useId","labelProps","onClick","props","ref","setInteractionModality","onFocus","onBlur","valueProps","id","isDisabled","modality","useInteractionModality","visuallyHiddenProps","useVisuallyHidden","containerProps","inputProps","tabIndex","style","fontSize","triggerRef","disabled","selectProps","size","value","onChange","e","useHiddenSelect","key","item","selectedKey"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaButtonProps} from '@react-types/button';\nimport {AriaSelectProps} from '@react-types/select';\nimport {filterDOMProps, mergeProps, useId} from '@react-aria/utils';\nimport {HTMLAttributes, RefObject, useMemo} from 'react';\nimport {KeyboardDelegate} from '@react-types/shared';\nimport {ListKeyboardDelegate, useTypeSelect} from '@react-aria/selection';\nimport {SelectState} from '@react-stately/select';\nimport {setInteractionModality} from '@react-aria/interactions';\nimport {useCollator} from '@react-aria/i18n';\nimport {useLabel} from '@react-aria/label';\nimport {useMenuTrigger} from '@react-aria/menu';\n\ninterface AriaSelectOptions<T> extends AriaSelectProps<T> {\n  /**\n   * An optional keyboard delegate implementation for type to select,\n   * to override the default.\n   */\n  keyboardDelegate?: KeyboardDelegate\n}\n\ninterface SelectAria {\n  /** Props for the label element. */\n  labelProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the popup trigger element. */\n  triggerProps: AriaButtonProps,\n\n  /** Props for the element representing the selected value. */\n  valueProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the popup. */\n  menuProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a select component.\n * A select displays a collapsible list of options and allows a user to select one of them.\n * @param props - Props for the select.\n * @param state - State for the select, as returned by `useListState`.\n */\nexport function useSelect<T>(props: AriaSelectOptions<T>, state: SelectState<T>, ref: RefObject<HTMLElement>): SelectAria {\n  let {\n    keyboardDelegate\n  } = props;\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = useCollator({usage: 'search', sensitivity: 'base'});\n  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(state.collection, state.disabledKeys, null, collator), [keyboardDelegate, state.collection, state.disabledKeys, collator]);\n\n  let {menuTriggerProps, menuProps} = useMenuTrigger(\n    {\n      type: 'listbox'\n    },\n    state,\n    ref\n  );\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: state.selectionManager,\n    onTypeSelect(key) {\n      state.setSelectedKey(key);\n    }\n  });\n\n  let {labelProps, fieldProps} = useLabel({\n    ...props,\n    labelElementType: 'span'\n  });\n\n  let domProps = filterDOMProps(props, {labelable: true});\n  let triggerProps = mergeProps(mergeProps(menuTriggerProps, fieldProps), typeSelectProps);\n  let valueId = useId();\n\n  return {\n    labelProps: {\n      ...labelProps,\n      onClick: () => {\n        if (!props.isDisabled) {\n          ref.current.focus();\n\n          // Show the focus ring so the user knows where focus went\n          setInteractionModality('keyboard');\n        }\n      }\n    },\n    triggerProps: mergeProps(domProps, {\n      ...triggerProps,\n      'aria-labelledby': [\n        triggerProps['aria-labelledby'],\n        triggerProps['aria-label'] && !triggerProps['aria-labelledby'] ? triggerProps.id : null,\n        valueId\n      ].filter(Boolean).join(' '),\n      onFocus() {\n        state.setFocused(true);\n      },\n      onBlur() {\n        state.setFocused(false);\n      }\n    }),\n    valueProps: {\n      id: valueId\n    },\n    menuProps: {\n      ...menuProps,\n      'aria-labelledby': [\n        fieldProps['aria-labelledby'],\n        triggerProps['aria-label'] && !fieldProps['aria-labelledby'] ? triggerProps.id : null\n      ].filter(Boolean).join(' ')\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport React, {ReactNode, RefObject} from 'react';\nimport {SelectState} from '@react-stately/select';\nimport {useInteractionModality} from '@react-aria/interactions';\nimport {useVisuallyHidden} from '@react-aria/visually-hidden';\n\ninterface AriaHiddenSelectProps {\n  /** The text label for the select. */\n  label?: ReactNode,\n\n  /** HTML form input name. */\n  name?: string,\n\n  /** Sets the disabled state of the select and input. */\n  isDisabled?: boolean\n}\n\ninterface HiddenSelectProps<T> extends AriaHiddenSelectProps {\n  /** State for the select. */\n  state: SelectState<T>,\n\n  /** A ref to the trigger element. */\n  triggerRef: RefObject<HTMLElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a hidden `<select>` element, which\n * can be used in combination with `useSelect` to support browser form autofill, mobile form\n * navigation, and native HTML form submission.\n */\nexport function useHiddenSelect<T>(props: AriaHiddenSelectProps, state: SelectState<T>, triggerRef: RefObject<HTMLElement>) {\n  let {name, isDisabled} = props;\n  let modality = useInteractionModality();\n  let {visuallyHiddenProps} = useVisuallyHidden();\n\n  // In Safari, the <select> cannot have `display: none` or `hidden` for autofill to work.\n  // In Firefox, there must be a <label> to identify the <select> whereas other browsers\n  // seem to identify it just by surrounding text.\n  // The solution is to use <VisuallyHidden> to hide the elements, which clips the elements to a\n  // 1px rectangle. In addition, we hide from screen readers with aria-hidden, and make the <select>\n  // non tabbable with tabIndex={-1}.\n  //\n  // In mobile browsers, there are next/previous buttons above the software keyboard for navigating\n  // between fields in a form. These only support native form inputs that are tabbable. In order to\n  // support those, an additional hidden input is used to marshall focus to the button. It is tabbable\n  // except when the button is focused, so that shift tab works properly to go to the actual previous\n  // input in the form. Using the <select> for this also works, but Safari on iOS briefly flashes\n  // the native menu on focus, so this isn't ideal. A font-size of 16px or greater is required to\n  // prevent Safari from zooming in on the input when it is focused.\n  //\n  // If the current interaction modality is null, then the user hasn't interacted with the page yet.\n  // In this case, we set the tabIndex to -1 on the input element so that automated accessibility\n  // checkers don't throw false-positives about focusable elements inside an aria-hidden parent.\n  return {\n    containerProps: {\n      ...visuallyHiddenProps,\n      'aria-hidden': true\n    },\n    inputProps: {\n      type: 'text',\n      tabIndex: modality == null || state.isFocused || state.isOpen ? -1 : 0,\n      style: {fontSize: 16},\n      onFocus: () => triggerRef.current.focus(),\n      disabled: isDisabled\n    },\n    selectProps: {\n      tabIndex: -1,\n      disabled: isDisabled,\n      name,\n      size: state.collection.size,\n      value: state.selectedKey ?? '',\n      onChange: (e: React.ChangeEvent<HTMLSelectElement>) => state.setSelectedKey(e.target.value)\n    }\n  };\n}\n\n/**\n * Renders a hidden native `<select>` element, which can be used to support browser\n * form autofill, mobile form navigation, and native form submission.\n */\nexport function HiddenSelect<T>(props: HiddenSelectProps<T>) {\n  let {state, triggerRef, label, name, isDisabled} = props;\n  let {containerProps, inputProps, selectProps} = useHiddenSelect(props, state, triggerRef);\n\n  // If used in a <form>, use a hidden input so the value can be submitted to a server.\n  // If the collection isn't too big, use a hidden <select> element for this so that browser\n  // autofill will work. Otherwise, use an <input type=\"hidden\">.\n  if (state.collection.size <= 300) {\n    return (\n      <div {...containerProps}>\n        <input {...inputProps} />\n        <label>\n          {label}\n          <select {...selectProps}>\n            {[...state.collection.getKeys()].map(key => {\n              let item = state.collection.getItem(key);\n              if (item.type === 'item') {\n                return (\n                  <option\n                    key={item.key}\n                    value={item.key}>\n                    {item.textValue}\n                  </option>\n                );\n              }\n            })}\n          </select>\n        </label>\n      </div>\n    );\n  } else if (name) {\n    return (\n      <input\n        type=\"hidden\"\n        name={name}\n        disabled={isDisabled}\n        value={state.selectedKey} />\n    );\n  }\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}