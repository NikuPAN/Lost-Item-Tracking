{"ast":null,"code":"import { useLocale } from \"@react-aria/i18n\";\nimport { useLabel } from \"@react-aria/label\";\nimport { usePress, useFocusWithin } from \"@react-aria/interactions\";\nimport { useFocusable, getFocusableTreeWalker } from \"@react-aria/focus\";\nimport { filterDOMProps, mergeProps, useId } from \"@react-aria/utils\";\nimport _babelRuntimeHelpersEsmExtends from \"@babel/runtime/helpers/esm/extends\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $a7d0e5df3871fb1bfdb437cffdabab2a$export$radioGroupNames = new WeakMap();\n/**\n * Provides the behavior and accessibility implementation for an individual\n * radio button in a radio group.\n * @param props - Props for the radio.\n * @param state - State for the radio group, as returned by `useRadioGroupState`.\n * @param ref - Ref to the HTML input element.\n */\n\nexport function useRadio(props, state, ref) {\n  let {\n    value,\n    isRequired,\n    isReadOnly,\n    isDisabled,\n    children,\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledby\n  } = props;\n  let hasChildren = children != null;\n  let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;\n\n  if (!hasChildren && !hasAriaLabel) {\n    console.warn('If you do not provide children, you must specify an aria-label for accessibility');\n  }\n\n  let checked = state.selectedValue === value;\n\n  let onChange = e => {\n    e.stopPropagation();\n    state.setSelectedValue(value);\n  };\n\n  let {\n    pressProps\n  } = usePress({\n    isDisabled\n  });\n  let {\n    focusableProps\n  } = useFocusable(mergeProps(props, {\n    onFocus: () => state.setLastFocusedValue(value)\n  }), ref);\n  let interactions = mergeProps(pressProps, focusableProps);\n  let domProps = filterDOMProps(props, {\n    labelable: true\n  });\n  let tabIndex = state.lastFocusedValue === value || state.lastFocusedValue == null ? 0 : -1;\n\n  if (isDisabled) {\n    tabIndex = undefined;\n  }\n\n  return {\n    inputProps: mergeProps(domProps, _babelRuntimeHelpersEsmExtends({}, interactions, {\n      type: 'radio',\n      name: $a7d0e5df3871fb1bfdb437cffdabab2a$export$radioGroupNames.get(state),\n      tabIndex,\n      disabled: isDisabled,\n      readOnly: isReadOnly,\n      required: isRequired,\n      checked,\n      value,\n      onChange\n    }))\n  };\n}\n/**\n * Provides the behavior and accessibility implementation for a radio group component.\n * Radio groups allow users to select a single item from a list of mutually exclusive options.\n * @param props - Props for the radio group.\n * @param state - State for the radio group, as returned by `useRadioGroupState`.\n */\n\nexport function useRadioGroup(props, state) {\n  let {\n    name,\n    validationState,\n    isReadOnly,\n    isRequired,\n    isDisabled,\n    orientation = 'vertical'\n  } = props;\n  let {\n    direction\n  } = useLocale();\n  let {\n    labelProps,\n    fieldProps\n  } = useLabel(_babelRuntimeHelpersEsmExtends({}, props, {\n    // Radio group is not an HTML input element so it\n    // shouldn't be labeled by a <label> element.\n    labelElementType: 'span'\n  }));\n  let domProps = filterDOMProps(props, {\n    labelable: true\n  }); // When the radio group loses focus, reset the focusable radio to null if\n  // there is no selection. This allows tabbing into the group from either\n  // direction to go to the first or last radio.\n\n  let {\n    focusWithinProps\n  } = useFocusWithin({\n    onBlurWithin() {\n      if (!state.selectedValue) {\n        state.setLastFocusedValue(null);\n      }\n    }\n\n  });\n\n  let onKeyDown = e => {\n    let nextDir;\n\n    switch (e.key) {\n      case 'ArrowRight':\n        if (direction === 'rtl' && orientation !== 'vertical') {\n          nextDir = 'prev';\n        } else {\n          nextDir = 'next';\n        }\n\n        break;\n\n      case 'ArrowLeft':\n        if (direction === 'rtl' && orientation !== 'vertical') {\n          nextDir = 'next';\n        } else {\n          nextDir = 'prev';\n        }\n\n        break;\n\n      case 'ArrowDown':\n        nextDir = 'next';\n        break;\n\n      case 'ArrowUp':\n        nextDir = 'prev';\n        break;\n\n      default:\n        return;\n    }\n\n    e.preventDefault();\n    let walker = getFocusableTreeWalker(e.currentTarget, {\n      from: e.target\n    });\n    let nextElem;\n\n    if (nextDir === 'next') {\n      nextElem = walker.nextNode();\n\n      if (!nextElem) {\n        walker.currentNode = e.currentTarget;\n        nextElem = walker.firstChild();\n      }\n    } else {\n      nextElem = walker.previousNode();\n\n      if (!nextElem) {\n        walker.currentNode = e.currentTarget;\n        nextElem = walker.lastChild();\n      }\n    }\n\n    if (nextElem) {\n      // Call focus on nextElem so that keyboard navigation scrolls the radio into view\n      nextElem.focus();\n      state.setSelectedValue(nextElem.value);\n    }\n  };\n\n  let groupName = useId(name);\n  $a7d0e5df3871fb1bfdb437cffdabab2a$export$radioGroupNames.set(state, groupName);\n  return {\n    radioGroupProps: mergeProps(domProps, _babelRuntimeHelpersEsmExtends({\n      // https://www.w3.org/TR/wai-aria-1.2/#radiogroup\n      role: 'radiogroup',\n      onKeyDown,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': props['aria-errormessage'],\n      'aria-readonly': isReadOnly || undefined,\n      'aria-required': isRequired || undefined,\n      'aria-disabled': isDisabled || undefined,\n      'aria-orientation': orientation\n    }, fieldProps, focusWithinProps)),\n    labelProps\n  };\n}","map":{"version":3,"sources":["packages/@react-aria/radio/src/utils.ts","packages/@react-aria/radio/src/useRadio.ts","packages/@react-aria/radio/src/useRadioGroup.ts"],"names":["radioGroupNames","ariaLabelledby","hasChildren","children","hasAriaLabel","ariaLabel","console","checked","state","onChange","e","pressProps","usePress","isDisabled","focusableProps","useFocusable","mergeProps","onFocus","interactions","domProps","filterDOMProps","labelable","tabIndex","inputProps","type","name","disabled","readOnly","required","orientation","direction","useLocale","fieldProps","useLabel","labelElementType","focusWithinProps","useFocusWithin","onBlurWithin","onKeyDown","nextDir","walker","getFocusableTreeWalker","from","target","nextElem","groupName","useId","radioGroupProps","role","validationState","props","isReadOnly","isRequired","labelProps"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {RadioGroupState} from '@react-stately/radio';\n\nexport const radioGroupNames = new WeakMap<RadioGroupState, string>();\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaRadioProps} from '@react-types/radio';\nimport {filterDOMProps, mergeProps} from '@react-aria/utils';\nimport {InputHTMLAttributes, RefObject} from 'react';\nimport {radioGroupNames} from './utils';\nimport {RadioGroupState} from '@react-stately/radio';\nimport {useFocusable} from '@react-aria/focus';\nimport {usePress} from '@react-aria/interactions';\n\ninterface RadioAriaProps extends AriaRadioProps {\n  /**\n   * Whether the Radio is required. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/required).\n   */\n  isRequired?: boolean,\n  /**\n   * Whether the Radio can be interacted with but cannot have its selection state changed.\n   */\n  isReadOnly?: boolean\n}\n\ninterface RadioAria {\n  /** Props for the input element. */\n  inputProps: InputHTMLAttributes<HTMLElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for an individual\n * radio button in a radio group.\n * @param props - Props for the radio.\n * @param state - State for the radio group, as returned by `useRadioGroupState`.\n * @param ref - Ref to the HTML input element.\n */\nexport function useRadio(props: RadioAriaProps, state: RadioGroupState, ref: RefObject<HTMLElement>): RadioAria {\n  let {\n    value,\n    isRequired,\n    isReadOnly,\n    isDisabled,\n    children,\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledby\n  } = props;\n\n  let hasChildren = children != null;\n  let hasAriaLabel = ariaLabel != null || ariaLabelledby != null;\n  if (!hasChildren && !hasAriaLabel) {\n    console.warn('If you do not provide children, you must specify an aria-label for accessibility');\n  }\n\n  let checked = state.selectedValue === value;\n\n  let onChange = (e) => {\n    e.stopPropagation();\n    state.setSelectedValue(value);\n  };\n\n  let {pressProps} = usePress({\n    isDisabled\n  });\n\n  let {focusableProps} = useFocusable(mergeProps(props, {\n    onFocus: () => state.setLastFocusedValue(value)\n  }), ref);\n  let interactions = mergeProps(pressProps, focusableProps);\n  let domProps = filterDOMProps(props, {labelable: true});\n  let tabIndex = state.lastFocusedValue === value || state.lastFocusedValue == null ? 0 : -1;\n  if (isDisabled) {\n    tabIndex = undefined;\n  }\n\n  return {\n    inputProps: mergeProps(domProps, {\n      ...interactions,\n      type: 'radio',\n      name: radioGroupNames.get(state),\n      tabIndex,\n      disabled: isDisabled,\n      readOnly: isReadOnly,\n      required: isRequired,\n      checked,\n      value,\n      onChange\n    })\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaRadioGroupProps} from '@react-types/radio';\nimport {filterDOMProps, mergeProps, useId} from '@react-aria/utils';\nimport {getFocusableTreeWalker} from '@react-aria/focus';\nimport {HTMLAttributes} from 'react';\nimport {radioGroupNames} from './utils';\nimport {RadioGroupState} from '@react-stately/radio';\nimport {useFocusWithin} from '@react-aria/interactions';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\ninterface RadioGroupAria {\n  /** Props for the radio group wrapper element. */\n  radioGroupProps: HTMLAttributes<HTMLElement>,\n  /** Props for the radio group's visible label (if any). */\n  labelProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a radio group component.\n * Radio groups allow users to select a single item from a list of mutually exclusive options.\n * @param props - Props for the radio group.\n * @param state - State for the radio group, as returned by `useRadioGroupState`.\n */\nexport function useRadioGroup(props: AriaRadioGroupProps, state: RadioGroupState): RadioGroupAria {\n  let {\n    name,\n    validationState,\n    isReadOnly,\n    isRequired,\n    isDisabled,\n    orientation = 'vertical'\n  } = props;\n  let {direction} = useLocale();\n\n  let {labelProps, fieldProps} = useLabel({\n    ...props,\n    // Radio group is not an HTML input element so it\n    // shouldn't be labeled by a <label> element.\n    labelElementType: 'span'\n  });\n\n  let domProps = filterDOMProps(props, {labelable: true});\n\n  // When the radio group loses focus, reset the focusable radio to null if\n  // there is no selection. This allows tabbing into the group from either\n  // direction to go to the first or last radio.\n  let {focusWithinProps} = useFocusWithin({\n    onBlurWithin() {\n      if (!state.selectedValue) {\n        state.setLastFocusedValue(null);\n      }\n    }\n  });\n\n  let onKeyDown = (e) => {\n    let nextDir;\n    switch (e.key) {\n      case 'ArrowRight':\n        if (direction === 'rtl' && orientation !== 'vertical') {\n          nextDir = 'prev';\n        } else {\n          nextDir = 'next';\n        }\n        break;\n      case 'ArrowLeft':\n        if (direction === 'rtl' && orientation !== 'vertical') {\n          nextDir = 'next';\n        } else {\n          nextDir = 'prev';\n        }\n        break;\n      case 'ArrowDown':\n        nextDir = 'next';\n        break;\n      case 'ArrowUp':\n        nextDir = 'prev';\n        break;\n      default:\n        return;\n    }\n    e.preventDefault();\n    let walker = getFocusableTreeWalker(e.currentTarget, {from: e.target});\n    let nextElem;\n    if (nextDir === 'next') {\n      nextElem = walker.nextNode();\n      if (!nextElem) {\n        walker.currentNode = e.currentTarget;\n        nextElem = walker.firstChild();\n      }\n    } else {\n      nextElem = walker.previousNode();\n      if (!nextElem) {\n        walker.currentNode = e.currentTarget;\n        nextElem = walker.lastChild();\n      }\n    }\n    if (nextElem) {\n      // Call focus on nextElem so that keyboard navigation scrolls the radio into view\n      nextElem.focus();\n      state.setSelectedValue(nextElem.value);\n    }\n  };\n\n  let groupName = useId(name);\n  radioGroupNames.set(state, groupName);\n\n  return {\n    radioGroupProps: mergeProps(domProps, {\n      // https://www.w3.org/TR/wai-aria-1.2/#radiogroup\n      role: 'radiogroup',\n      onKeyDown,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': props['aria-errormessage'],\n      'aria-readonly': isReadOnly || undefined,\n      'aria-required': isRequired || undefined,\n      'aria-disabled': isDisabled || undefined,\n      'aria-orientation': orientation,\n      ...fieldProps,\n      ...focusWithinProps\n    }),\n    labelProps\n  };\n}\n"]},"metadata":{},"sourceType":"module"}