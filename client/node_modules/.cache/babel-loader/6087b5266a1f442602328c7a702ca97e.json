{"ast":null,"code":"import { useLayoutEffect } from \"@react-aria/utils\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n// import {Point} from './Point';\n// import { DragTarget, DropTarget } from '@react-types/shared';\n\n/**\n * [CollectionView]{@link CollectionView} supports arbitrary layout objects, which compute what views are visible, and how\n * to position and style them. However, layouts do not create the views themselves directly. Instead,\n * layouts produce lightweight {@link LayoutInfo} objects which describe various properties of a view,\n * such as its position and size. The {@link CollectionView} is then responsible for creating the actual\n * views as needed, based on this layout information.\n *\n * Every layout extends from the {@link Layout} abstract base class. Layouts must implement a minimum of the\n * two methods listed below. All other methods can be optionally overridden to implement custom behavior.\n *\n * @see {@link getVisibleLayoutInfos}\n * @see {@link getLayoutInfo}\n */\n\nexport class Layout {\n  constructor() {\n    this.virtualizer = void 0;\n  }\n  /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   */\n\n\n  shouldInvalidate(newRect, oldRect) {\n    // By default, invalidate when the size changes\n    return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n  }\n  /**\n   * This method allows the layout to perform any pre-computation\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n   * Called by the collection view before {@link getVisibleLayoutInfos}\n   * or {@link getLayoutInfo} are called.\n   */\n\n\n  validate(invalidationContext) {} // eslint-disable-line @typescript-eslint/no-unused-vars\n\n  /**\n   * Returns an array of {@link LayoutInfo} objects which are inside the given rectangle.\n   * Should be implemented by subclasses.\n   * @param rect The rectangle that should contain the returned LayoutInfo objects.\n   */\n\n  /**\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n   * @param point The point at which the drag occurred.\n   */\n  // getDragTarget(point: Point): DragTarget | null {\n  //   let target = this.virtualizer.keyAtPoint(point);\n  //   if (!target) {\n  //     return null;\n  //   }\n  //   return {\n  //     type: 'item',\n  //     key: target\n  //   };\n  // }\n\n  /**\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n   * to reject the drop. The dropped items will be inserted before the resulting target.\n   * @param point The point at which the drop occurred.\n   */\n  // getDropTarget(point: Point): DropTarget | null {\n  //   return null;\n  // }\n\n  /**\n   * Returns the starting attributes for an animated insertion.\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n   * The default implementation just returns its input.\n   *\n   * @param layoutInfo The proposed LayoutInfo for this view.\n   */\n\n\n  getInitialLayoutInfo(layoutInfo) {\n    return layoutInfo;\n  }\n  /**\n   * Returns the ending attributes for an animated removal.\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n   * to the one returned by this method. The default implementation returns its input.\n   *\n   * @param layoutInfo The original LayoutInfo for this view.\n   */\n\n\n  getFinalLayoutInfo(layoutInfo) {\n    return layoutInfo;\n  }\n\n}\n/**\n * Instances of this lightweight class are created by {@link Layout} subclasses\n * to represent each view in the {@link CollectionView}. LayoutInfo objects describe\n * various properties of a view, such as its position and size, and style information.\n * The collection view uses this information when creating actual views to display.\n */\n\nexport class LayoutInfo {\n  /**\n   * A string representing the view type. Should be `'item'` for item views.\n   * Other types are used by supplementary views.\n   */\n\n  /**\n   * A unique key for this view. For item views, it should match the content key.\n   */\n\n  /**\n   * The key for a parent layout info, if any.\n   */\n\n  /**\n   * The rectangle describing the size and position of this view.\n   */\n\n  /**\n   * Whether the size is estimated. `false` by default.\n   */\n\n  /**\n   * Whether the layout info sticks to the viewport when scrolling.\n   */\n\n  /**\n   * The view's opacity. 1 by default.\n   */\n\n  /**\n   * A CSS transform string to apply to the view. `null` by default.\n   */\n\n  /**\n   * The z-index of the view. 0 by default.\n   */\n\n  /**\n   * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n   * @param key The unique key for this view.\n   * @param rect The rectangle describing the size and position of this view.\n   */\n  constructor(type, key, rect) {\n    this.type = void 0;\n    this.key = void 0;\n    this.parentKey = void 0;\n    this.rect = void 0;\n    this.estimatedSize = void 0;\n    this.isSticky = void 0;\n    this.opacity = void 0;\n    this.transform = void 0;\n    this.zIndex = void 0;\n    this.type = type;\n    this.key = key;\n    this.parentKey = null;\n    this.rect = rect;\n    this.estimatedSize = false;\n    this.isSticky = false;\n    this.opacity = 1;\n    this.transform = null;\n    this.zIndex = 0;\n  }\n  /**\n   * Returns a copy of the LayoutInfo.\n   */\n\n\n  copy() {\n    let res = new LayoutInfo(this.type, this.key, this.rect.copy());\n    res.estimatedSize = this.estimatedSize;\n    res.opacity = this.opacity;\n    res.transform = this.transform;\n    res.parentKey = this.parentKey;\n    res.isSticky = this.isSticky;\n    return res;\n  }\n\n}\nexport class Point {\n  /** The x-coordinate of the point. */\n\n  /** The y-coordinate of the point. */\n  constructor(x, y) {\n    if (x === void 0) {\n      x = 0;\n    }\n\n    if (y === void 0) {\n      y = 0;\n    }\n\n    this.x = void 0;\n    this.y = void 0;\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Returns a copy of this point.\n   */\n\n\n  copy() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Checks if two points are equal.\n   */\n\n\n  equals(point) {\n    return this.x === point.x && this.y === point.y;\n  }\n  /**\n   * Returns true if this point is the origin.\n   */\n\n\n  isOrigin() {\n    return this.x === 0 && this.y === 0;\n  }\n\n}\n/**\n * Represents a rectangle.\n */\n\nexport class Rect {\n  /** The x-coordinate of the rectangle. */\n\n  /** The y-coordinate of the rectangle. */\n\n  /** The width of the rectangle. */\n\n  /** The height of the rectangle. */\n  constructor(x, y, width, height) {\n    if (x === void 0) {\n      x = 0;\n    }\n\n    if (y === void 0) {\n      y = 0;\n    }\n\n    if (width === void 0) {\n      width = 0;\n    }\n\n    if (height === void 0) {\n      height = 0;\n    }\n\n    this.x = void 0;\n    this.y = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n  /**\n   * The maximum x-coordinate in the rectangle.\n   */\n\n\n  get maxX() {\n    return this.x + this.width;\n  }\n  /**\n   * The maximum y-coordinate in the rectangle.\n   */\n\n\n  get maxY() {\n    return this.y + this.height;\n  }\n  /**\n   * The area of the rectangle.\n   */\n\n\n  get area() {\n    return this.width * this.height;\n  }\n  /**\n   * The top left corner of the rectangle.\n   */\n\n\n  get topLeft() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * The top right corner of the rectangle.\n   */\n\n\n  get topRight() {\n    return new Point(this.maxX, this.y);\n  }\n  /**\n   * The bottom left corner of the rectangle.\n   */\n\n\n  get bottomLeft() {\n    return new Point(this.x, this.maxY);\n  }\n  /**\n   * The bottom right corner of the rectangle.\n   */\n\n\n  get bottomRight() {\n    return new Point(this.maxX, this.maxY);\n  }\n  /**\n   * Returns whether this rectangle intersects another rectangle.\n   * @param rect - The rectangle to check.\n   */\n\n\n  intersects(rect) {\n    return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n  }\n  /**\n   * Returns whether this rectangle fully contains another rectangle.\n   * @param rect - The rectangle to check.\n   */\n\n\n  containsRect(rect) {\n    return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n  }\n  /**\n   * Returns whether the rectangle contains the given point.\n   * @param point - The point to check.\n   */\n\n\n  containsPoint(point) {\n    return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n  }\n  /**\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\n   * @param rect - The rectangle to check.\n   */\n\n\n  getCornerInRect(rect) {\n    for (let key of ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']) {\n      if (rect.containsPoint(this[key])) {\n        return key;\n      }\n    }\n\n    return null;\n  }\n\n  equals(rect) {\n    return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n  }\n\n  pointEquals(point) {\n    return this.x === point.x && this.y === point.y;\n  }\n\n  sizeEquals(size) {\n    return this.width === size.width && this.height === size.height;\n  }\n  /**\n   * Returns a copy of this rectangle.\n   */\n\n\n  copy() {\n    return new Rect(this.x, this.y, this.width, this.height);\n  }\n\n}\nexport class Size {\n  constructor(width, height) {\n    if (width === void 0) {\n      width = 0;\n    }\n\n    if (height === void 0) {\n      height = 0;\n    }\n\n    this.width = void 0;\n    this.height = void 0;\n    this.width = width;\n    this.height = height;\n  }\n  /**\n   * Returns a copy of this size.\n   */\n\n\n  copy() {\n    return new Size(this.width, this.height);\n  }\n  /**\n   * Returns whether this size is equal to another one.\n   */\n\n\n  equals(other) {\n    return this.width === other.width && this.height === other.height;\n  }\n\n}\nlet $db50d694530b1570aea7db33f212f7$var$KEY = 0;\n/**\n * [CollectionView]{@link CollectionView} creates instances of the [ReusableView]{@link ReusableView} class to\n * represent views currently being displayed. ReusableViews manage a DOM node, handle\n * applying {@link LayoutInfo} objects to the view, and render content\n * as needed. Subclasses must implement the {@link render} method at a\n * minimum. Other methods can be overridden to customize behavior.\n */\n\nexport class ReusableView {\n  /** The CollectionVirtualizer this view is a part of. */\n\n  /** The LayoutInfo this view is currently representing. */\n\n  /** The content currently being displayed by this view, set by the collection view. */\n  constructor(virtualizer) {\n    this.virtualizer = void 0;\n    this.layoutInfo = void 0;\n    this.content = void 0;\n    this.rendered = void 0;\n    this.viewType = void 0;\n    this.key = void 0;\n    this.virtualizer = virtualizer;\n    this.key = ++$db50d694530b1570aea7db33f212f7$var$KEY;\n  }\n  /**\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\n   */\n\n\n  prepareForReuse() {\n    this.content = null;\n    this.rendered = null;\n    this.layoutInfo = null;\n  }\n\n} // use high res timer if available\n\nlet $ea7b4dd250709a616043c0e9cf5f62a$var$perf = typeof window !== 'undefined' ? window.performance : null; // @ts-ignore\n\nlet $ea7b4dd250709a616043c0e9cf5f62a$var$perfNow = $ea7b4dd250709a616043c0e9cf5f62a$var$perf && ($ea7b4dd250709a616043c0e9cf5f62a$var$perf.now || $ea7b4dd250709a616043c0e9cf5f62a$var$perf.webkitNow || $ea7b4dd250709a616043c0e9cf5f62a$var$perf.msNow || $ea7b4dd250709a616043c0e9cf5f62a$var$perf.mozNow);\nlet $ea7b4dd250709a616043c0e9cf5f62a$var$getTime = $ea7b4dd250709a616043c0e9cf5f62a$var$perfNow ? $ea7b4dd250709a616043c0e9cf5f62a$var$perfNow.bind($ea7b4dd250709a616043c0e9cf5f62a$var$perf) : function () {\n  return Date.now ? Date.now() : new Date().getTime();\n};\nlet $ea7b4dd250709a616043c0e9cf5f62a$var$fixTs;\n\nfunction $ea7b4dd250709a616043c0e9cf5f62a$export$tween(begin, end, duration, ease, fn) {\n  let canceled = false;\n  let raf_id;\n  let promise = new Promise(resolve => {\n    let start = $ea7b4dd250709a616043c0e9cf5f62a$var$getTime();\n    let diffX = end.x - begin.x;\n    let diffY = end.y - begin.y;\n    raf_id = requestAnimationFrame(function run(t) {\n      // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n      // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n      if ($ea7b4dd250709a616043c0e9cf5f62a$var$fixTs == null) {\n        $ea7b4dd250709a616043c0e9cf5f62a$var$fixTs = t > 1e12 !== $ea7b4dd250709a616043c0e9cf5f62a$var$getTime() > 1e12;\n      }\n\n      if ($ea7b4dd250709a616043c0e9cf5f62a$var$fixTs) {\n        t = $ea7b4dd250709a616043c0e9cf5f62a$var$getTime();\n      } // check if we're done\n\n\n      let delta = t - start;\n\n      if (delta > duration) {\n        fn(end);\n        resolve();\n      } else {\n        // call frame callback after computing eased time and get the next frame\n        let proceed = fn(new Point(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n\n        if (proceed !== false && !canceled) {\n          raf_id = requestAnimationFrame(run);\n        }\n      }\n    });\n  });\n\n  promise.cancel = function () {\n    canceled = true;\n    cancelAnimationFrame(raf_id);\n  };\n\n  return promise;\n} // easing functions\n\n\nfunction $ea7b4dd250709a616043c0e9cf5f62a$export$easeOut(t) {\n  return Math.sin(t * Math.PI / 2);\n}\n\nfunction $e73002b1b269f5d359247972bfd09$export$keyDiff(a, b) {\n  let res = new Set();\n\n  for (let key of a.keys()) {\n    if (!b.has(key)) {\n      res.add(key);\n    }\n  }\n\n  return res;\n}\n/**\n * Returns the key difference between two maps. Returns a set of\n * keys to add to and remove from a to make it equal to b.\n * @private\n */\n\n\nfunction $e73002b1b269f5d359247972bfd09$export$difference(a, b) {\n  let toRemove = $e73002b1b269f5d359247972bfd09$export$keyDiff(a, b);\n  let toAdd = $e73002b1b269f5d359247972bfd09$export$keyDiff(b, a);\n  let toUpdate = new Set();\n\n  for (let key of a.keys()) {\n    if (b.has(key)) {\n      toUpdate.add(key);\n    }\n  }\n\n  return {\n    toRemove,\n    toAdd,\n    toUpdate\n  };\n}\n/**\n * Returns an iterator that yields the items in all of the given iterators.\n * @private\n */\n\n\nfunction* $e73002b1b269f5d359247972bfd09$export$concatIterators() {\n  for (var _len = arguments.length, iterators = new Array(_len), _key = 0; _key < _len; _key++) {\n    iterators[_key] = arguments[_key];\n  }\n\n  for (let iterator of iterators) {\n    yield* iterator;\n  }\n}\n/**\n * Inverts the keys and values of an object.\n * @private\n */\n\n\nclass $e15f96b53dee9114a5d189b4490e08b$var$RollingAverage {\n  constructor() {\n    this.count = 0;\n    this.value = 0;\n  }\n\n  addSample(sample) {\n    this.count++;\n    this.value += (sample - this.value) / this.count;\n  }\n\n}\n\nclass $e15f96b53dee9114a5d189b4490e08b$export$OverscanManager {\n  constructor() {\n    this.startTime = 0;\n    this.averagePerf = new $e15f96b53dee9114a5d189b4490e08b$var$RollingAverage();\n    this.averageTime = new $e15f96b53dee9114a5d189b4490e08b$var$RollingAverage();\n    this.velocity = new Point(5, 5);\n    this.overscanX = new $e15f96b53dee9114a5d189b4490e08b$var$RollingAverage();\n    this.overscanY = new $e15f96b53dee9114a5d189b4490e08b$var$RollingAverage();\n    this.visibleRect = new Rect();\n  }\n\n  setVisibleRect(rect) {\n    let time = performance.now() - this.startTime;\n\n    if (time < 500) {\n      this.averageTime.addSample(time);\n\n      if (rect.x !== this.visibleRect.x && time > 0) {\n        this.velocity.x = (rect.x - this.visibleRect.x) / time;\n      }\n\n      if (rect.y !== this.visibleRect.y && time > 0) {\n        this.velocity.y = (rect.y - this.visibleRect.y) / time;\n      }\n    }\n\n    this.startTime = performance.now();\n    this.visibleRect = rect;\n  }\n\n  collectMetrics() {\n    let time = performance.now() - this.startTime;\n\n    if (time < 500) {\n      this.averagePerf.addSample(time);\n    }\n\n    if (this.visibleRect.height > 0) {\n      let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n      this.overscanY.addSample(o);\n    }\n\n    if (this.visibleRect.width > 0) {\n      let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n      this.overscanX.addSample(o);\n    }\n  }\n\n  getOverscannedRect() {\n    let overscanned = this.visibleRect.copy();\n    let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n\n    if (this.velocity.y > 0) {\n      overscanned.y -= overscanY * 0.2;\n      overscanned.height += overscanY + overscanY * 0.2;\n    } else {\n      overscanned.y -= overscanY;\n      overscanned.height += overscanY + overscanY * 0.2;\n    }\n\n    let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n\n    if (this.velocity.x > 0) {\n      overscanned.x -= overscanX * 0.2;\n      overscanned.width += overscanX + overscanX * 0.2;\n    } else {\n      overscanned.x -= overscanX;\n      overscanned.width += overscanX + overscanX * 0.2;\n    }\n\n    return overscanned;\n  }\n\n}\n\nclass $ab2c59ad03985fabe3061564f2$export$Transaction {\n  constructor() {\n    this.level = 0;\n    this.actions = [];\n    this.animated = true;\n    this.initialMap = new Map();\n    this.finalMap = new Map();\n    this.initialLayoutInfo = new Map();\n    this.finalLayoutInfo = new Map();\n    this.removed = new Map();\n    this.toRemove = new Map();\n  }\n\n}\n/**\n * The CollectionView class renders a scrollable collection of data using customizable layouts,\n * and manages animated updates to the data over time. It supports very large collections by\n * only rendering visible views to the DOM, reusing them as you scroll. Collection views can\n * present any type of view, including non-item views such as section headers and footers.\n * Optionally, the {@link EditableCollectionView} subclass can be used to enable user interaction\n * with the collection, including drag and drop, multiple selection, and keyboard interacton.\n *\n * Collection views get their data from a {@link DataSource} object that you provide. Items are\n * grouped into sections by the data source, and the collection view calls its methods to retrieve\n * the data. When data changes, the data source emits change events, and the collection view\n * updates as appropriate, optionally with an animated transition. There is one built-in data source\n * implementation, {@link ArrayDataSource}, which renders content from a 2d array.\n *\n * Collection views use {@link Layout} objects to compute what views should be visible, and how\n * to position and style them. This means that collection views can have their items arranged in\n * a stack, a grid, a circle, or any other layout you can think of. The layout can be changed\n * dynamically at runtime as well, optionally with an animated transition between the layouts.\n *\n * Layouts produce information on what views should appear in the collection view, but do not create\n * the views themselves directly. It is the responsibility of the {@link CollectionViewDelegate} object\n * to create instances of {@link ReusableView} subclasses which render the items into DOM nodes.\n * The delegate determines what type of view to display for each item, and creates instances of\n * views as needed by the collection view. Those views are then reused by the collection view as\n * the user scrolls through the content.\n */\n\n\nclass $d389afd47bc06952d9e630a237a8$export$Virtualizer {\n  /**\n   * The collection view delegate. The delegate is used by the collection view\n   * to create and configure views.\n   */\n\n  /** The duration of animated layout changes, in milliseconds. Default is 500ms. */\n\n  /**\n   * Whether to enable scroll anchoring. This will attempt to restore the scroll position\n   * after layout changes outside the viewport. Default is off.\n   */\n\n  /** Whether to anchor the scroll position when at the top of the content. Default is off. */\n\n  /**\n   * Whether to overscan the visible area to pre-render items slightly outside and\n   * improve performance. Default is on.\n   */\n  constructor(options) {\n    var _options$transitionDu;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.delegate = void 0;\n    this.transitionDuration = void 0;\n    this.anchorScrollPosition = void 0;\n    this.anchorScrollPositionAtTop = void 0;\n    this.shouldOverscan = void 0;\n    this._collection = void 0;\n    this._layout = void 0;\n    this._contentSize = void 0;\n    this._visibleRect = void 0;\n    this._visibleLayoutInfos = void 0;\n    this._reusableViews = void 0;\n    this._visibleViews = void 0;\n    this._renderedContent = void 0;\n    this._children = void 0;\n    this._invalidationContext = void 0;\n    this._overscanManager = void 0;\n    this._relayoutRaf = void 0;\n    this._scrollAnimation = void 0;\n    this._isScrolling = void 0;\n    this._sizeUpdateQueue = void 0;\n    this._animatedContentOffset = void 0;\n    this._transaction = void 0;\n    this._nextTransaction = void 0;\n    this._transactionQueue = void 0;\n    this._contentSize = new Size();\n    this._visibleRect = new Rect();\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new $e15f96b53dee9114a5d189b4490e08b$export$OverscanManager();\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new Point(0, 0);\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = []; // Set options from passed object if given\n\n    this.transitionDuration = (_options$transitionDu = options.transitionDuration) != null ? _options$transitionDu : 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n\n    for (let key of ['delegate', 'size', 'layout', 'collection']) {\n      if (options[key]) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  _setContentSize(size) {\n    this._contentSize = size;\n    this.delegate.setContentSize(size);\n  }\n\n  _setContentOffset(offset) {\n    let rect = new Rect(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n    this.delegate.setVisibleRect(rect);\n  }\n  /**\n   * Get the size of the scrollable content.\n   */\n\n\n  get contentSize() {\n    return this._contentSize;\n  }\n  /**\n   * Get the collection view's currently visible rectangle.\n   */\n\n\n  get visibleRect() {\n    return this._visibleRect;\n  }\n  /**\n   * Set the collection view's currently visible rectangle.\n   */\n\n\n  set visibleRect(rect) {\n    this._setVisibleRect(rect);\n  }\n\n  _setVisibleRect(rect, forceUpdate) {\n    if (forceUpdate === void 0) {\n      forceUpdate = false;\n    }\n\n    let current = this._visibleRect; // Ignore if the rects are equal\n\n    if (rect.equals(current)) {\n      return;\n    }\n\n    if (this.shouldOverscan) {\n      this._overscanManager.setVisibleRect(rect);\n    }\n\n    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n\n    this._resetAnimatedContentOffset();\n\n    this._visibleRect = rect;\n\n    if (shouldInvalidate) {\n      this.relayout({\n        offsetChanged: !rect.pointEquals(current),\n        sizeChanged: !rect.sizeEquals(current)\n      });\n    } else {\n      this.updateSubviews(forceUpdate);\n    }\n  }\n\n  get collection() {\n    return this._collection;\n  }\n\n  set collection(data) {\n    this._setData(data);\n  }\n\n  _setData(data) {\n    if (data === this._collection) {\n      return;\n    }\n\n    if (this._collection) {\n      this._runTransaction(() => {\n        this._collection = data;\n      }, this.transitionDuration > 0);\n    } else {\n      this._collection = data;\n      this.reloadData();\n    }\n  }\n  /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */\n\n\n  reloadData() {\n    this.relayout({\n      contentChanged: true\n    });\n  }\n  /**\n   * Returns the item with the given key.\n   */\n\n\n  getItem(key) {\n    return this._collection ? this._collection.getItem(key) : null;\n  }\n  /**\n   * Get the collection view's layout.\n   */\n\n\n  get layout() {\n    return this._layout;\n  }\n  /**\n   * Set the collection view's layout.\n   */\n\n\n  set layout(layout) {\n    this.setLayout(layout);\n  }\n  /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */\n\n\n  setLayout(layout, animated) {\n    if (animated === void 0) {\n      animated = false;\n    }\n\n    if (layout === this._layout) {\n      return;\n    }\n\n    let applyLayout = () => {\n      if (this._layout) {\n        // @ts-ignore\n        this._layout.virtualizer = null;\n      }\n\n      layout.virtualizer = this;\n      this._layout = layout;\n    };\n\n    if (animated) {\n      // Animated layout transitions are really simple, thanks to our transaction support.\n      // We just set the layout inside a transaction action, which runs after the initial\n      // layout infos for the animation are retrieved from the previous layout. Then, the\n      // final layout infos are retrieved from the new layout, and animations occur.\n      this._runTransaction(applyLayout);\n    } else {\n      applyLayout();\n      this.relayout();\n    }\n  }\n\n  _getReuseType(layoutInfo, content) {\n    if (layoutInfo.type === 'item' && content) {\n      let type = this.delegate.getType ? this.delegate.getType(content) : 'item';\n      let reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;\n      return {\n        type,\n        reuseType\n      };\n    }\n\n    return {\n      type: layoutInfo.type,\n      reuseType: layoutInfo.type\n    };\n  }\n\n  getReusableView(layoutInfo) {\n    let content = this.getItem(layoutInfo.key);\n\n    let {\n      reuseType\n    } = this._getReuseType(layoutInfo, content);\n\n    if (!this._reusableViews[reuseType]) {\n      this._reusableViews[reuseType] = [];\n    }\n\n    let reusable = this._reusableViews[reuseType];\n    let view = reusable.length > 0 ? reusable.pop() : new ReusableView(this);\n    view.viewType = reuseType;\n\n    if (!this._animatedContentOffset.isOrigin()) {\n      layoutInfo = layoutInfo.copy();\n      layoutInfo.rect.x += this._animatedContentOffset.x;\n      layoutInfo.rect.y += this._animatedContentOffset.y;\n    }\n\n    view.layoutInfo = layoutInfo;\n\n    this._renderView(view);\n\n    return view;\n  }\n\n  _renderView(reusableView) {\n    let {\n      type,\n      key\n    } = reusableView.layoutInfo;\n    reusableView.content = this.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n\n  _renderContent(type, content) {\n    let cached = this._renderedContent.get(content);\n\n    if (cached != null) {\n      return cached;\n    }\n\n    let rendered = this.delegate.renderView(type, content);\n\n    if (content) {\n      this._renderedContent.set(content, rendered);\n    }\n\n    return rendered;\n  }\n  /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */\n\n\n  get visibleViews() {\n    return Array.from(this._visibleViews.values());\n  }\n  /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */\n\n\n  getView(key) {\n    return this._visibleViews.get(key) || null;\n  }\n  /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */\n\n\n  getViewsOfType(type) {\n    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);\n  }\n  /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */\n\n\n  keyForView(view) {\n    if (view && view.layoutInfo) {\n      return view.layoutInfo.key;\n    }\n\n    return null;\n  }\n  /**\n   * Returns the key for the item view currently at the given point.\n   */\n\n\n  keyAtPoint(point) {\n    let rect = new Rect(point.x, point.y, 1, 1);\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let layoutInfo = layoutInfos[0];\n\n    if (!layoutInfo) {\n      return null;\n    }\n\n    return layoutInfo.key;\n  }\n  /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */\n\n\n  willUnmount() {\n    cancelAnimationFrame(this._relayoutRaf);\n  }\n  /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */\n\n\n  relayout(context) {\n    if (context === void 0) {\n      context = {};\n    } // Ignore relayouts while animating the scroll position\n\n\n    if (this._scrollAnimation || typeof requestAnimationFrame === 'undefined') {\n      return;\n    } // If we already scheduled a relayout, extend the invalidation\n    // context so we coalesce multiple relayouts in the same frame.\n\n\n    if (this._invalidationContext) {\n      Object.assign(this._invalidationContext, context);\n      return;\n    }\n\n    this._invalidationContext = context;\n    this._relayoutRaf = requestAnimationFrame(() => {\n      this._relayoutRaf = null;\n      this.relayoutNow();\n    });\n  }\n  /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */\n\n\n  relayoutNow(context) {\n    if (context === void 0) {\n      context = this._invalidationContext || {};\n    } // Cancel the scheduled relayout, since we're doing it now.\n\n\n    if (this._relayoutRaf) {\n      cancelAnimationFrame(this._relayoutRaf);\n      this._relayoutRaf = null;\n    } // Reset the invalidation context\n\n\n    this._invalidationContext = null; // Do nothing if we don't have a layout or content, or we are\n    // in the middle of an animated scroll transition.\n\n    if (!this.layout || !this._collection || this._scrollAnimation) {\n      return;\n    }\n\n    let scrollAnchor = this._getScrollAnchor(); // Trigger the beforeLayout hook, if provided\n\n\n    if (typeof context.beforeLayout === 'function') {\n      context.beforeLayout();\n    } // Validate the layout\n\n\n    this.layout.validate(context);\n\n    this._setContentSize(this.layout.getContentSize()); // Trigger the afterLayout hook, if provided\n\n\n    if (typeof context.afterLayout === 'function') {\n      context.afterLayout();\n    } // Adjust scroll position based on scroll anchor, and constrain.\n    // If the content changed, scroll to the top.\n\n\n    let visibleRect = this.getVisibleRect();\n\n    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n\n    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n    let hasLayoutUpdates = false;\n\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n      // Save the difference between the current and new content offsets, and apply it to the\n      // individual content items instead. At the end of the animation, we'll reset and set the\n      // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n      // the scroll animation and the content animation.\n      if (context.animated || !this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n        hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n      } else {\n        this._setContentOffset(new Point(contentOffsetX, contentOffsetY));\n      }\n    } else {\n      hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n    } // Apply layout infos, unless this is coming from an animated transaction\n\n\n    if (!(context.transaction && context.animated)) {\n      this._applyLayoutInfos();\n    } // Wait for animations, and apply the afterAnimation hook, if provided\n\n\n    if (context.animated && hasLayoutUpdates) {\n      this._enableTransitions();\n\n      let done = () => {\n        this._disableTransitions(); // Reset scroll position after animations (see above comment).\n\n\n        if (!this._animatedContentOffset.isOrigin()) {\n          // Get the content offset to scroll to, taking _animatedContentOffset into account.\n          let {\n            x,\n            y\n          } = this.getVisibleRect();\n\n          this._resetAnimatedContentOffset();\n\n          this._setContentOffset(new Point(x, y));\n        }\n\n        if (typeof context.afterAnimation === 'function') {\n          context.afterAnimation();\n        }\n      }; // Sometimes the animation takes slightly longer than expected.\n\n\n      setTimeout(done, this.transitionDuration + 100);\n      return;\n    } else if (typeof context.afterAnimation === 'function') {\n      context.afterAnimation();\n    }\n  }\n  /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */\n\n\n  _correctItemOrder() {\n    // Defer until after scrolling and animated transactions are complete\n    if (this._isScrolling || this._transaction) {\n      return;\n    }\n\n    for (let key of this._visibleLayoutInfos.keys()) {\n      let view = this._visibleViews.get(key);\n\n      this._children.delete(view);\n\n      this._children.add(view);\n    }\n  }\n\n  _enableTransitions() {\n    this.delegate.beginAnimations();\n  }\n\n  _disableTransitions() {\n    this.delegate.endAnimations();\n  }\n\n  _getScrollAnchor() {\n    if (!this.anchorScrollPosition) {\n      return null;\n    }\n\n    let visibleRect = this.getVisibleRect(); // Ask the delegate to provide a scroll anchor, if possible\n\n    if (this.delegate.getScrollAnchor) {\n      let key = this.delegate.getScrollAnchor(visibleRect);\n\n      if (key) {\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n        if (corner) {\n          let key = layoutInfo.key;\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          return {\n            key,\n            layoutInfo,\n            corner,\n            offset\n          };\n        }\n      }\n    } // No need to anchor the scroll position if it is at the top\n\n\n    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) {\n      return null;\n    } // Find a view with a visible corner that has the smallest distance to the top of the collection view\n\n\n    let cornerAnchor = null;\n\n    for (let [key, view] of this._visibleViews) {\n      let layoutInfo = view.layoutInfo;\n\n      if (layoutInfo && layoutInfo.rect.area > 0) {\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n        if (corner) {\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n\n          if (!cornerAnchor || offset < cornerAnchor.offset) {\n            cornerAnchor = {\n              key,\n              layoutInfo,\n              corner,\n              offset\n            };\n          }\n        }\n      }\n    }\n\n    return cornerAnchor;\n  }\n\n  _restoreScrollAnchor(scrollAnchor, context) {\n    let contentOffset = this.getVisibleRect();\n\n    if (scrollAnchor) {\n      var _context$transaction;\n\n      let finalAnchor = ((_context$transaction = context.transaction) == null ? void 0 : _context$transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n\n      if (finalAnchor) {\n        let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n        contentOffset.y += adjustment;\n      }\n    }\n\n    return contentOffset;\n  }\n\n  getVisibleRect() {\n    let v = this.visibleRect;\n    let x = v.x - this._animatedContentOffset.x;\n    let y = v.y - this._animatedContentOffset.y;\n    return new Rect(x, y, v.width, v.height);\n  }\n\n  getVisibleLayoutInfos() {\n    let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n    return this._visibleLayoutInfos;\n  }\n\n  _getLayoutInfoMap(rect, copy) {\n    if (copy === void 0) {\n      copy = false;\n    }\n\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map();\n\n    for (let layoutInfo of layoutInfos) {\n      if (copy) {\n        layoutInfo = layoutInfo.copy();\n      }\n\n      map.set(layoutInfo.key, layoutInfo);\n    }\n\n    return map;\n  }\n\n  updateSubviews(forceUpdate) {\n    if (forceUpdate === void 0) {\n      forceUpdate = false;\n    }\n\n    if (!this._collection) {\n      return;\n    }\n\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let currentlyVisible = this._visibleViews;\n    let toAdd, toRemove, toUpdate; // If this is a force update, remove and re-add all views.\n    // Otherwise, find and update the diff.\n\n    if (forceUpdate) {\n      toAdd = visibleLayoutInfos;\n      toRemove = currentlyVisible;\n      toUpdate = new Set();\n    } else {\n      ({\n        toAdd,\n        toRemove,\n        toUpdate\n      } = $e73002b1b269f5d359247972bfd09$export$difference(currentlyVisible, visibleLayoutInfos));\n\n      for (let key of toUpdate) {\n        let view = currentlyVisible.get(key);\n\n        if (!view || !view.layoutInfo) {\n          continue;\n        }\n\n        let item = this.getItem(visibleLayoutInfos.get(key).key);\n\n        if (view.content === item) {\n          toUpdate.delete(key);\n        } else {\n          // If the view type changes, delete and recreate the view instead of updating\n          let {\n            reuseType\n          } = this._getReuseType(view.layoutInfo, item);\n\n          if (view.viewType !== reuseType) {\n            toUpdate.delete(key);\n            toAdd.add(key);\n            toRemove.add(key);\n          }\n        }\n      } // We are done if the sets are equal\n\n\n      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n        if (this._transaction) {\n          this._applyLayoutInfos();\n        }\n\n        return;\n      }\n    } // Track views that should be removed. They are not removed from\n    // the DOM immediately, since we may reuse and need to re-insert\n    // them back into the DOM anyway.\n\n\n    let removed = new Set();\n\n    for (let key of toRemove.keys()) {\n      let view = this._visibleViews.get(key);\n\n      if (view) {\n        removed.add(view);\n\n        this._visibleViews.delete(key); // If we are in the middle of a transaction, wait until the end\n        // of the animations to remove the views from the DOM. Also means\n        // we can't reuse those views immediately.\n\n\n        if (this._transaction) {\n          this._transaction.toRemove.set(key, view);\n        } else {\n          this.reuseView(view);\n        }\n      }\n    }\n\n    for (let key of toAdd.keys()) {\n      let layoutInfo = visibleLayoutInfos.get(key);\n      let view; // If we're in a transaction, and a layout change happens\n      // during the animations such that a view that was going\n      // to be removed is now not, we don't create a new view\n      // since the old one is still in the DOM, marked as toRemove.\n\n      if (this._transaction) {\n        // if transaction, get initial layout attributes for the animation\n        if (this._transaction.initialLayoutInfo.has(key)) {\n          layoutInfo = this._transaction.initialLayoutInfo.get(key);\n        }\n\n        view = this._transaction.toRemove.get(key);\n\n        if (view) {\n          this._transaction.toRemove.delete(key);\n\n          this._applyLayoutInfo(view, layoutInfo);\n        }\n      }\n\n      if (!view) {\n        // Create or reuse a view for this row\n        view = this.getReusableView(layoutInfo); // Add the view to the DOM if needed\n\n        if (!removed.has(view)) {\n          this._children.add(view);\n        }\n      }\n\n      this._visibleViews.set(key, view);\n\n      removed.delete(view);\n    }\n\n    for (let key of toUpdate) {\n      let view = currentlyVisible.get(key);\n\n      this._renderedContent.delete(key);\n\n      this._renderView(view);\n    } // Remove the remaining rows to delete from the DOM\n\n\n    if (!this._transaction) {\n      this.removeViews(removed);\n    }\n\n    this._correctItemOrder();\n\n    this._flushVisibleViews();\n\n    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n\n    if (hasLayoutUpdates) {\n      requestAnimationFrame(() => {\n        // If we're in a transaction, apply animations to visible views\n        // and \"to be removed\" views, which animate off screen.\n        if (this._transaction) {\n          requestAnimationFrame(() => this._applyLayoutInfos());\n        }\n      });\n    }\n\n    return hasLayoutUpdates;\n  }\n\n  afterRender() {\n    if (this.shouldOverscan) {\n      this._overscanManager.collectMetrics();\n    }\n  }\n\n  _flushVisibleViews() {\n    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n    // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n    // method to build the final tree.\n    let viewsByParentKey = new Map([[null, []]]);\n\n    for (let view of this._children) {\n      if (!viewsByParentKey.has(view.layoutInfo.parentKey)) {\n        viewsByParentKey.set(view.layoutInfo.parentKey, []);\n      }\n\n      viewsByParentKey.get(view.layoutInfo.parentKey).push(view);\n\n      if (!viewsByParentKey.has(view.layoutInfo.key)) {\n        viewsByParentKey.set(view.layoutInfo.key, []);\n      }\n    }\n\n    let buildTree = (parent, views) => views.map(view => {\n      let children = viewsByParentKey.get(view.layoutInfo.key);\n      return this.delegate.renderWrapper(parent, view, children, childViews => buildTree(view, childViews));\n    });\n\n    let children = buildTree(null, viewsByParentKey.get(null));\n    this.delegate.setVisibleViews(children);\n  }\n\n  _applyLayoutInfo(view, layoutInfo) {\n    if (view.layoutInfo === layoutInfo) {\n      return false;\n    }\n\n    view.layoutInfo = layoutInfo;\n    return true;\n  }\n\n  _applyLayoutInfos() {\n    let updated = false; // Apply layout infos to visible views\n\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n\n      if (cur) {\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    } // Apply final layout infos for views that will be removed\n\n\n    if (this._transaction) {\n      for (let view of this._transaction.toRemove.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n\n      for (let view of this._transaction.removed.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      this._flushVisibleViews();\n    }\n  }\n\n  _hasLayoutUpdates() {\n    if (!this._transaction) {\n      return false;\n    }\n\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n\n      if (!cur) {\n        return true;\n      }\n\n      let layoutInfo = this.layout.getLayoutInfo(cur.key);\n\n      if (!cur.rect.pointEquals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  reuseView(view) {\n    view.prepareForReuse();\n\n    this._reusableViews[view.viewType].push(view);\n  }\n\n  removeViews(toRemove) {\n    for (let view of toRemove) {\n      this._children.delete(view);\n    }\n  }\n\n  updateItemSize(key, size) {\n    // TODO: we should be able to invalidate a single index path\n    // @ts-ignore\n    if (!this.layout.updateItemSize) {\n      return;\n    } // If the scroll position is currently animating, add the update\n    // to a queue to be processed after the animation is complete.\n\n\n    if (this._scrollAnimation) {\n      this._sizeUpdateQueue.set(key, size);\n\n      return;\n    } // @ts-ignore\n\n\n    let changed = this.layout.updateItemSize(key, size);\n\n    if (changed) {\n      this.relayout();\n    }\n  }\n\n  startScrolling() {\n    this._isScrolling = true;\n  }\n\n  endScrolling() {\n    this._isScrolling = false;\n\n    this._correctItemOrder();\n\n    this._flushVisibleViews();\n  }\n\n  _resetAnimatedContentOffset() {\n    // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n    if (!this._animatedContentOffset.isOrigin()) {\n      this._animatedContentOffset = new Point(0, 0);\n\n      this._applyLayoutInfos();\n    }\n  }\n  /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */\n\n\n  scrollToItem(key, options) {\n    if (!key) {\n      return;\n    }\n\n    let layoutInfo = this.layout.getLayoutInfo(key);\n\n    if (!layoutInfo) {\n      return;\n    }\n\n    let {\n      duration = 300,\n      shouldScrollX = true,\n      shouldScrollY = true,\n      offsetX = 0,\n      offsetY = 0\n    } = options;\n    let x = this.visibleRect.x;\n    let y = this.visibleRect.y;\n    let minX = layoutInfo.rect.x - offsetX;\n    let minY = layoutInfo.rect.y - offsetY;\n    let maxX = x + this.visibleRect.width;\n    let maxY = y + this.visibleRect.height;\n\n    if (shouldScrollX) {\n      if (minX <= x || maxX === 0) {\n        x = minX;\n      } else if (layoutInfo.rect.maxX > maxX) {\n        x += layoutInfo.rect.maxX - maxX;\n      }\n    }\n\n    if (shouldScrollY) {\n      if (minY <= y || maxY === 0) {\n        y = minY;\n      } else if (layoutInfo.rect.maxY > maxY) {\n        y += layoutInfo.rect.maxY - maxY;\n      }\n    }\n\n    return this.scrollTo(new Point(x, y), duration);\n  }\n  /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */\n\n\n  scrollTo(offset, duration) {\n    if (duration === void 0) {\n      duration = 300;\n    } // Cancel the current scroll animation\n\n\n    if (this._scrollAnimation) {\n      this._scrollAnimation.cancel();\n\n      this._scrollAnimation = null;\n    } // Set the content offset synchronously if the duration is zero\n\n\n    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n      this._setContentOffset(offset);\n\n      return Promise.resolve();\n    }\n\n    this.startScrolling();\n    this._scrollAnimation = $ea7b4dd250709a616043c0e9cf5f62a$export$tween(this.visibleRect, offset, duration, $ea7b4dd250709a616043c0e9cf5f62a$export$easeOut, offset => {\n      this._setContentOffset(offset);\n    });\n\n    this._scrollAnimation.then(() => {\n      this._scrollAnimation = null; // Process view size updates that occurred during the animation.\n      // Only views that are still visible will be actually updated.\n\n      for (let [key, size] of this._sizeUpdateQueue) {\n        this.updateItemSize(key, size);\n      }\n\n      this._sizeUpdateQueue.clear();\n\n      this.relayout();\n\n      this._processTransactionQueue();\n\n      this.endScrolling();\n    });\n\n    return this._scrollAnimation;\n  }\n\n  _runTransaction(action, animated) {\n    this._startTransaction();\n\n    if (this._nextTransaction) {\n      this._nextTransaction.actions.push(action);\n    }\n\n    this._endTransaction(animated);\n  }\n\n  _startTransaction() {\n    if (!this._nextTransaction) {\n      this._nextTransaction = new $ab2c59ad03985fabe3061564f2$export$Transaction();\n    }\n\n    this._nextTransaction.level++;\n  }\n\n  _endTransaction(animated) {\n    if (!this._nextTransaction) {\n      return false;\n    } // Save whether the transaction should be animated.\n\n\n    if (animated != null) {\n      this._nextTransaction.animated = animated;\n    } // If we haven't reached level 0, we are still in a\n    // nested transaction. Wait for the parent to end.\n\n\n    if (--this._nextTransaction.level > 0) {\n      return false;\n    } // Do nothing for empty transactions\n\n\n    if (this._nextTransaction.actions.length === 0) {\n      this._nextTransaction = null;\n      return false;\n    } // Default animations to true\n\n\n    if (this._nextTransaction.animated == null) {\n      this._nextTransaction.animated = true;\n    } // Enqueue the transaction\n\n\n    this._transactionQueue.push(this._nextTransaction);\n\n    this._nextTransaction = null;\n\n    this._processTransactionQueue();\n\n    return true;\n  }\n\n  _processTransactionQueue() {\n    // If the current transaction is animating, wait until the end\n    // to process the next transaction.\n    if (this._transaction || this._scrollAnimation) {\n      return;\n    }\n\n    let next = this._transactionQueue.shift();\n\n    if (next) {\n      this._performTransaction(next);\n    }\n  }\n\n  _getContentRect() {\n    return new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n  }\n\n  _performTransaction(transaction) {\n    this._transaction = transaction;\n    this.relayoutNow({\n      transaction: transaction,\n      animated: transaction.animated,\n      beforeLayout: () => {\n        // Get the initial layout infos for all views before the updates\n        // so we can figure out which views to add and remove.\n        if (transaction.animated) {\n          transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n        } // Apply the actions that occurred during this transaction\n\n\n        for (let action of transaction.actions) {\n          action();\n        }\n      },\n      afterLayout: () => {\n        // Get the final layout infos after the updates\n        if (transaction.animated) {\n          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n\n          this._setupTransactionAnimations(transaction);\n        } else {\n          this._transaction = null;\n        }\n      },\n      afterAnimation: () => {\n        // Remove and reuse views when animations are done\n        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) {\n          for (let view of $e73002b1b269f5d359247972bfd09$export$concatIterators(transaction.toRemove.values(), transaction.removed.values())) {\n            this._children.delete(view);\n\n            this.reuseView(view);\n          }\n        }\n\n        this._transaction = null; // Ensure DOM order is correct for accessibility after animations are complete\n\n        this._correctItemOrder();\n\n        this._flushVisibleViews();\n\n        this._processTransactionQueue();\n      }\n    });\n  }\n\n  _setupTransactionAnimations(transaction) {\n    let {\n      initialMap,\n      finalMap\n    } = transaction; // Store initial and final layout infos for animations\n\n    for (let [key, layoutInfo] of initialMap) {\n      if (finalMap.has(key)) {\n        // Store the initial layout info for use during animations.\n        transaction.initialLayoutInfo.set(key, layoutInfo);\n      } else {\n        // This view was removed. Store the layout info for use\n        // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n      }\n    } // Get initial layout infos for views that were added\n\n\n    for (let [key, layoutInfo] of finalMap) {\n      if (!initialMap.has(key)) {\n        let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n        transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n      }\n    } // Figure out which views were removed.\n\n\n    for (let [key, view] of this._visibleViews) {\n      if (!finalMap.has(key)) {\n        transaction.removed.set(key, view);\n\n        this._visibleViews.delete(key); // In case something weird happened, where we have a view but no\n        // initial layout info, use the one attached to the view.\n\n\n        if (view.layoutInfo) {\n          if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) {\n            transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n          }\n        }\n      }\n    }\n  }\n\n}\n\nexport function useVirtualizerState(opts) {\n  let [visibleViews, setVisibleViews] = useState([]);\n  let [contentSize, setContentSize] = useState(new Size());\n  let [isAnimating, setAnimating] = useState(false);\n  let [isScrolling, setScrolling] = useState(false);\n  let virtualizer = useMemo(() => new $d389afd47bc06952d9e630a237a8$export$Virtualizer(), []);\n  virtualizer.delegate = {\n    setVisibleViews,\n\n    setVisibleRect(rect) {\n      virtualizer.visibleRect = rect;\n      opts.onVisibleRectChange(rect);\n    },\n\n    setContentSize,\n    renderView: opts.renderView,\n    renderWrapper: opts.renderWrapper,\n    beginAnimations: () => setAnimating(true),\n    endAnimations: () => setAnimating(false),\n    getScrollAnchor: opts.getScrollAnchor\n  };\n  virtualizer.layout = opts.layout;\n  virtualizer.collection = opts.collection;\n  virtualizer.transitionDuration = opts.transitionDuration;\n  useLayoutEffect(() => {\n    virtualizer.afterRender();\n  }); // eslint-disable-next-line arrow-body-style\n\n  useEffect(() => {\n    return () => virtualizer.willUnmount();\n  }, []);\n  return {\n    virtualizer,\n    visibleViews,\n    setVisibleRect: useCallback(rect => {\n      virtualizer.visibleRect = rect;\n    }, [virtualizer]),\n    contentSize,\n    isAnimating,\n    isScrolling,\n    startScrolling: useCallback(() => {\n      virtualizer.startScrolling();\n      setScrolling(true);\n    }, [virtualizer]),\n    endScrolling: useCallback(() => {\n      virtualizer.endScrolling();\n      setScrolling(false);\n    }, [virtualizer])\n  };\n}","map":{"version":3,"sources":["packages/@react-stately/virtualizer/src/Layout.ts","packages/@react-stately/virtualizer/src/LayoutInfo.ts","packages/@react-stately/virtualizer/src/Point.ts","packages/@react-stately/virtualizer/src/Rect.ts","packages/@react-stately/virtualizer/src/Size.ts","packages/@react-stately/virtualizer/src/ReusableView.ts","packages/@react-stately/virtualizer/src/tween.ts","packages/@react-stately/virtualizer/src/utils.ts","packages/@react-stately/virtualizer/src/OverscanManager.ts","packages/@react-stately/virtualizer/src/Transaction.ts","packages/@react-stately/virtualizer/src/Virtualizer.ts","packages/@react-stately/virtualizer/src/useVirtualizerState.ts"],"names":["shouldInvalidate","newRect","oldRect","validate","getInitialLayoutInfo","getFinalLayoutInfo","type","key","parentKey","rect","estimatedSize","isSticky","opacity","transform","zIndex","constructor","copy","res","x","y","equals","point","isOrigin","width","height","intersects","containsRect","containsPoint","getCornerInRect","pointEquals","sizeEquals","size","other","KEY","virtualizer","layoutInfo","content","rendered","viewType","prepareForReuse","perf","window","perfNow","getTime","Date","canceled","promise","resolve","start","diffX","end","begin","diffY","raf_id","requestAnimationFrame","fixTs","t","delta","fn","proceed","ease","cancelAnimationFrame","Math","a","b","toRemove","keyDiff","toAdd","toUpdate","iterators","addSample","sample","setVisibleRect","time","performance","collectMetrics","o","getOverscannedRect","overscanned","overscanY","overscanX","delegate","transitionDuration","anchorScrollPosition","anchorScrollPositionAtTop","shouldOverscan","_collection","_layout","_contentSize","_visibleRect","_visibleLayoutInfos","_reusableViews","_visibleViews","_renderedContent","_children","_invalidationContext","_overscanManager","_relayoutRaf","_scrollAnimation","_isScrolling","_sizeUpdateQueue","_animatedContentOffset","_transaction","_nextTransaction","_transactionQueue","options","_setContentSize","_setContentOffset","offset","_setVisibleRect","forceUpdate","current","offsetChanged","sizeChanged","_setData","data","reloadData","contentChanged","getItem","setLayout","animated","layout","applyLayout","_getReuseType","reuseType","getReusableView","reusable","view","_renderView","reusableView","_renderContent","cached","Array","getView","getViewsOfType","v","keyForView","keyAtPoint","layoutInfos","willUnmount","relayout","context","Object","relayoutNow","scrollAnchor","visibleRect","restoredScrollAnchor","contentOffsetX","contentOffsetY","hasLayoutUpdates","done","setTimeout","_correctItemOrder","_enableTransitions","_disableTransitions","_getScrollAnchor","corner","cornerAnchor","_restoreScrollAnchor","contentOffset","finalAnchor","adjustment","getVisibleRect","getVisibleLayoutInfos","_getLayoutInfoMap","map","updateSubviews","visibleLayoutInfos","currentlyVisible","item","removed","afterRender","_flushVisibleViews","viewsByParentKey","buildTree","children","childViews","_applyLayoutInfo","_applyLayoutInfos","updated","cur","_hasLayoutUpdates","reuseView","removeViews","updateItemSize","changed","startScrolling","endScrolling","_resetAnimatedContentOffset","scrollToItem","duration","shouldScrollX","shouldScrollY","offsetX","offsetY","minX","minY","maxX","maxY","scrollTo","Promise","_runTransaction","_startTransaction","_endTransaction","_processTransactionQueue","next","_getContentRect","_performTransaction","transaction","beforeLayout","action","afterLayout","afterAnimation","_setupTransactionAnimations","finalMap","initialMap","initialLayoutInfo","useState","useMemo","opts","renderView","renderWrapper","beginAnimations","setAnimating","endAnimations","getScrollAnchor","useLayoutEffect","useEffect","useCallback","setScrolling"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {InvalidationContext} from './types';\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\n// import {Point} from './Point';\nimport {Rect} from './Rect';\nimport {Size} from './Size';\nimport {Virtualizer} from './Virtualizer';\n// import { DragTarget, DropTarget } from '@react-types/shared';\n\n/**\n * [CollectionView]{@link CollectionView} supports arbitrary layout objects, which compute what views are visible, and how\n * to position and style them. However, layouts do not create the views themselves directly. Instead,\n * layouts produce lightweight {@link LayoutInfo} objects which describe various properties of a view,\n * such as its position and size. The {@link CollectionView} is then responsible for creating the actual\n * views as needed, based on this layout information.\n *\n * Every layout extends from the {@link Layout} abstract base class. Layouts must implement a minimum of the\n * two methods listed below. All other methods can be optionally overridden to implement custom behavior.\n *\n * @see {@link getVisibleLayoutInfos}\n * @see {@link getLayoutInfo}\n */\nexport abstract class Layout<T extends object> {\n  /** The CollectionView the layout is currently attached to. */\n  virtualizer: Virtualizer<T, any, any>;\n\n  /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   */\n  shouldInvalidate(newRect: Rect, oldRect: Rect): boolean {\n    // By default, invalidate when the size changes\n    return newRect.width !== oldRect.width\n        || newRect.height !== oldRect.height;\n  }\n\n  /**\n   * This method allows the layout to perform any pre-computation\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n   * Called by the collection view before {@link getVisibleLayoutInfos}\n   * or {@link getLayoutInfo} are called.\n   */\n  validate(invalidationContext: InvalidationContext<T, any>) {} // eslint-disable-line @typescript-eslint/no-unused-vars\n\n  /**\n   * Returns an array of {@link LayoutInfo} objects which are inside the given rectangle.\n   * Should be implemented by subclasses.\n   * @param rect The rectangle that should contain the returned LayoutInfo objects.\n   */\n  abstract getVisibleLayoutInfos(rect: Rect): LayoutInfo[];\n\n  /**\n   * Returns a {@link LayoutInfo} for the given key.\n   * Should be implemented by subclasses.\n   * @param key The key of the LayoutInfo to retrieve.\n   */\n  abstract getLayoutInfo(key: Key): LayoutInfo;\n\n  /**\n   * Returns size of the content. By default, it returns collectionView's size.\n   */\n  abstract getContentSize(): Size;\n\n  /**\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n   * @param point The point at which the drag occurred.\n   */\n  // getDragTarget(point: Point): DragTarget | null {\n  //   let target = this.virtualizer.keyAtPoint(point);\n  //   if (!target) {\n  //     return null;\n  //   }\n\n  //   return {\n  //     type: 'item',\n  //     key: target\n  //   };\n  // }\n\n  /**\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n   * to reject the drop. The dropped items will be inserted before the resulting target.\n   * @param point The point at which the drop occurred.\n   */\n  // getDropTarget(point: Point): DropTarget | null {\n  //   return null;\n  // }\n\n  /**\n   * Returns the starting attributes for an animated insertion.\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n   * The default implementation just returns its input.\n   *\n   * @param layoutInfo The proposed LayoutInfo for this view.\n   */\n  getInitialLayoutInfo(layoutInfo: LayoutInfo): LayoutInfo {\n    return layoutInfo;\n  }\n\n  /**\n   * Returns the ending attributes for an animated removal.\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n   * to the one returned by this method. The default implementation returns its input.\n   *\n   * @param layoutInfo The original LayoutInfo for this view.\n   */\n  getFinalLayoutInfo(layoutInfo: LayoutInfo): LayoutInfo {\n    return layoutInfo;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {Rect} from './Rect';\n\n/**\n * Instances of this lightweight class are created by {@link Layout} subclasses\n * to represent each view in the {@link CollectionView}. LayoutInfo objects describe\n * various properties of a view, such as its position and size, and style information.\n * The collection view uses this information when creating actual views to display.\n */\nexport class LayoutInfo {\n  /**\n   * A string representing the view type. Should be `'item'` for item views.\n   * Other types are used by supplementary views.\n   */\n  type: string;\n\n  /**\n   * A unique key for this view. For item views, it should match the content key.\n   */\n  key: Key;\n\n  /**\n   * The key for a parent layout info, if any.\n   */\n  parentKey: Key | null;\n\n  /**\n   * The rectangle describing the size and position of this view.\n   */\n  rect: Rect;\n\n  /**\n   * Whether the size is estimated. `false` by default.\n   */\n  estimatedSize: boolean;\n\n  /**\n   * Whether the layout info sticks to the viewport when scrolling.\n   */\n  isSticky: boolean;\n\n  /**\n   * The view's opacity. 1 by default.\n   */\n  opacity: number;\n\n  /**\n   * A CSS transform string to apply to the view. `null` by default.\n   */\n  transform: string | null;\n\n  /**\n   * The z-index of the view. 0 by default.\n   */\n  zIndex: number;\n\n  /**\n   * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n   * @param key The unique key for this view.\n   * @param rect The rectangle describing the size and position of this view.\n   */\n  constructor(type: string, key: Key, rect: Rect) {\n    this.type = type;\n    this.key = key;\n    this.parentKey = null;\n    this.rect = rect;\n    this.estimatedSize = false;\n    this.isSticky = false;\n    this.opacity = 1;\n    this.transform = null;\n    this.zIndex = 0;\n  }\n\n  /**\n   * Returns a copy of the LayoutInfo.\n   */\n  copy(): LayoutInfo {\n    let res = new LayoutInfo(this.type, this.key, this.rect.copy());\n    res.estimatedSize = this.estimatedSize;\n    res.opacity = this.opacity;\n    res.transform = this.transform;\n    res.parentKey = this.parentKey;\n    res.isSticky = this.isSticky;\n    return res;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport class Point {\n  /** The x-coordinate of the point. */\n  x: number;\n\n  /** The y-coordinate of the point. */\n  y: number;\n\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Returns a copy of this point.\n   */\n  copy(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * Checks if two points are equal.\n   */\n  equals(point: Point): boolean {\n    return this.x === point.x && this.y === point.y;\n  }\n\n  /**\n   * Returns true if this point is the origin.\n   */\n  isOrigin(): boolean {\n    return this.x === 0 && this.y === 0;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\nimport {Size} from './Size';\n\nexport type RectCorner = 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';\n\n/**\n * Represents a rectangle.\n */\nexport class Rect {\n  /** The x-coordinate of the rectangle. */\n  x: number;\n\n  /** The y-coordinate of the rectangle. */\n  y: number;\n\n  /** The width of the rectangle. */\n  width: number;\n\n  /** The height of the rectangle. */\n  height: number;\n\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * The maximum x-coordinate in the rectangle.\n   */\n  get maxX(): number {\n    return this.x + this.width;\n  }\n\n  /**\n   * The maximum y-coordinate in the rectangle.\n   */\n  get maxY(): number {\n    return this.y + this.height;\n  }\n\n  /**\n   * The area of the rectangle.\n   */\n  get area(): number {\n    return this.width * this.height;\n  }\n\n  /**\n   * The top left corner of the rectangle.\n   */\n  get topLeft(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * The top right corner of the rectangle.\n   */\n  get topRight(): Point {\n    return new Point(this.maxX, this.y);\n  }\n\n  /**\n   * The bottom left corner of the rectangle.\n   */\n  get bottomLeft(): Point {\n    return new Point(this.x, this.maxY);\n  }\n\n  /**\n   * The bottom right corner of the rectangle.\n   */\n  get bottomRight(): Point {\n    return new Point(this.maxX, this.maxY);\n  }\n\n  /**\n   * Returns whether this rectangle intersects another rectangle.\n   * @param rect - The rectangle to check.\n   */\n  intersects(rect: Rect): boolean {\n    return this.x <= rect.x + rect.width\n        && rect.x <= this.x + this.width\n        && this.y <= rect.y + rect.height\n        && rect.y <= this.y + this.height;\n  }\n\n  /**\n   * Returns whether this rectangle fully contains another rectangle.\n   * @param rect - The rectangle to check.\n   */\n  containsRect(rect: Rect): boolean {\n    return this.x <= rect.x\n        && this.y <= rect.y\n        && this.maxX >= rect.maxX\n        && this.maxY >= rect.maxY;\n  }\n\n  /**\n   * Returns whether the rectangle contains the given point.\n   * @param point - The point to check.\n   */\n  containsPoint(point: Point): boolean {\n    return this.x <= point.x\n        && this.y <= point.y\n        && this.maxX >= point.x\n        && this.maxY >= point.y;\n  }\n\n  /**\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\n   * @param rect - The rectangle to check.\n   */\n  getCornerInRect(rect: Rect): RectCorner | null {\n    for (let key of ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']) {\n      if (rect.containsPoint(this[key])) {\n        return key as RectCorner;\n      }\n    }\n\n    return null;\n  }\n\n  equals(rect: Rect) {\n    return rect.x === this.x\n        && rect.y === this.y\n        && rect.width === this.width\n        && rect.height === this.height;\n  }\n\n  pointEquals(point: Point | Rect) {\n    return this.x === point.x\n        && this.y === point.y;\n  }\n\n  sizeEquals(size: Size | Rect) {\n    return this.width === size.width\n        && this.height === size.height;\n  }\n\n  /**\n   * Returns a copy of this rectangle.\n   */\n  copy(): Rect {\n    return new Rect(this.x, this.y, this.width, this.height);\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport class Size {\n  width: number;\n  height: number;\n\n  constructor(width = 0, height = 0) {\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * Returns a copy of this size.\n   */\n  copy(): Size {\n    return new Size(this.width, this.height);\n  }\n\n  /**\n   * Returns whether this size is equal to another one.\n   */\n  equals(other: Size): boolean {\n    return this.width === other.width\n        && this.height === other.height;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\nimport {Virtualizer} from './Virtualizer';\n\nlet KEY = 0;\n\n/**\n * [CollectionView]{@link CollectionView} creates instances of the [ReusableView]{@link ReusableView} class to\n * represent views currently being displayed. ReusableViews manage a DOM node, handle\n * applying {@link LayoutInfo} objects to the view, and render content\n * as needed. Subclasses must implement the {@link render} method at a\n * minimum. Other methods can be overridden to customize behavior.\n */\nexport class ReusableView<T extends object, V> {\n  /** The CollectionVirtualizer this view is a part of. */\n  virtualizer: Virtualizer<T, V, unknown>;\n\n  /** The LayoutInfo this view is currently representing. */\n  layoutInfo: LayoutInfo | null;\n\n  /** The content currently being displayed by this view, set by the collection view. */\n  content: T;\n\n  rendered: V;\n\n  viewType: string;\n  key: Key;\n\n  constructor(virtualizer: Virtualizer<T, V, unknown>) {\n    this.virtualizer = virtualizer;\n    this.key = ++KEY;\n  }\n\n  /**\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\n   */\n  prepareForReuse() {\n    this.content = null;\n    this.rendered = null;\n    this.layoutInfo = null;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\n\n// use high res timer if available\nlet perf = typeof window !== 'undefined' ? window.performance : null;\n// @ts-ignore\nlet perfNow = perf && (perf.now || perf.webkitNow || perf.msNow || perf.mozNow);\nlet getTime = perfNow ? perfNow.bind(perf) : function () {\n  return Date.now ? Date.now() : new Date().getTime();\n};\n\nlet fixTs: boolean;\n\nexport interface CancelablePromise<T> extends Promise<T> {\n  cancel(): void\n}\n\nexport function tween(begin, end, duration, ease, fn): CancelablePromise<void> {\n  let canceled = false;\n  let raf_id: number;\n\n  let promise = new Promise(resolve => {\n    let start = getTime();\n    let diffX = end.x - begin.x;\n    let diffY = end.y - begin.y;\n\n    raf_id = requestAnimationFrame(function run(t) {\n      // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n      // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n      if (fixTs == null) {\n        fixTs = t > 1e12 !== getTime() > 1e12;\n      }\n\n      if (fixTs) {\n        t = getTime();\n      }\n\n      // check if we're done\n      let delta = t - start;\n      if (delta > duration) {\n        fn(end);\n        resolve();\n      } else {\n        // call frame callback after computing eased time and get the next frame\n        let proceed = fn(new Point(\n          begin.x + diffX * ease(delta / duration),\n          begin.y + diffY * ease(delta / duration)\n        ));\n\n        if (proceed !== false && !canceled) {\n          raf_id = requestAnimationFrame(run);\n        }\n      }\n    });\n  }) as CancelablePromise<void>;\n\n  promise.cancel = function () {\n    canceled = true;\n    cancelAnimationFrame(raf_id);\n  };\n\n  return promise;\n}\n\n// easing functions\nexport function linearEasing(t) {\n  return t;\n}\n\nexport function easeOut(t) {\n  return Math.sin(t * Math.PI / 2);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport function keyDiff<T>(a: Map<T, any>, b: Map<T, any>): Set<T> {\n  let res = new Set<T>();\n\n  for (let key of a.keys()) {\n    if (!b.has(key)) {\n      res.add(key);\n    }\n  }\n\n  return res;\n}\n\n/**\n * Returns the key difference between two maps. Returns a set of\n * keys to add to and remove from a to make it equal to b.\n * @private\n */\nexport function difference<T>(a: Map<T, any>, b: Map<T, any>) {\n  let toRemove = keyDiff(a, b);\n  let toAdd = keyDiff(b, a);\n  let toUpdate = new Set;\n  for (let key of a.keys()) {\n    if (b.has(key)) {\n      toUpdate.add(key);\n    }\n  }\n  return {toRemove, toAdd, toUpdate};\n}\n\n/**\n * Returns an iterator that yields the items in all of the given iterators.\n * @private\n */\nexport function* concatIterators<T>(...iterators: Iterable<T>[]) {\n  for (let iterator of iterators) {\n    yield* iterator;\n  }\n}\n\n/**\n * Inverts the keys and values of an object.\n * @private\n */\nexport function invert(object) {\n  let res = {};\n  for (let key in object) {\n    res[object[key]] = key;\n  }\n\n  return res;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\nimport {Rect} from './Rect';\n\nclass RollingAverage {\n  private count: number = 0;\n  value: number = 0;\n  \n  addSample(sample: number) {\n    this.count++;\n    this.value += (sample - this.value) / this.count;\n  }\n}\n\nexport class OverscanManager {\n  private startTime = 0;\n  private averagePerf = new RollingAverage();\n  private averageTime = new RollingAverage();\n  private velocity = new Point(5, 5);\n  private overscanX = new RollingAverage();\n  private overscanY = new RollingAverage();\n  private visibleRect = new Rect();\n  \n  setVisibleRect(rect: Rect) {\n    let time = performance.now() - this.startTime;\n    if (time < 500) {\n      this.averageTime.addSample(time);\n\n      if (rect.x !== this.visibleRect.x && time > 0) {\n        this.velocity.x = (rect.x - this.visibleRect.x) / time;\n      }\n\n      if (rect.y !== this.visibleRect.y && time > 0) {\n        this.velocity.y = (rect.y - this.visibleRect.y) / time;\n      }\n    }\n\n    this.startTime = performance.now();\n    this.visibleRect = rect;\n  }\n\n  collectMetrics() {\n    let time = performance.now() - this.startTime;\n    if (time < 500) {\n      this.averagePerf.addSample(time);\n    }\n\n    if (this.visibleRect.height > 0) {\n      let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));  \n      this.overscanY.addSample(o);\n    }\n\n    if (this.visibleRect.width > 0) {\n      let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));  \n      this.overscanX.addSample(o);\n    }\n  }\n\n  getOverscannedRect() {\n    let overscanned = this.visibleRect.copy();\n\n    let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n    if (this.velocity.y > 0) {\n      overscanned.y -= overscanY * 0.2;\n      overscanned.height += overscanY + overscanY * 0.2;\n    } else {\n      overscanned.y -= overscanY;\n      overscanned.height += overscanY + overscanY * 0.2;\n    }\n\n    let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n    if (this.velocity.x > 0) {\n      overscanned.x -= overscanX * 0.2;\n      overscanned.width += overscanX + overscanX * 0.2;\n    } else {\n      overscanned.x -= overscanX;\n      overscanned.width += overscanX + overscanX * 0.2;\n    }\n\n    return overscanned;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\nimport {ReusableView} from './ReusableView';\n\ntype LayoutInfoMap = Map<Key, LayoutInfo>;\nexport class Transaction<T extends object, V> {\n  level = 0;\n  actions: (() => void)[] = [];\n  animated = true;\n  initialMap: LayoutInfoMap = new Map();\n  finalMap: LayoutInfoMap = new Map();\n  initialLayoutInfo: LayoutInfoMap = new Map();\n  finalLayoutInfo: LayoutInfoMap = new Map();\n  removed: Map<Key, ReusableView<T, V>> = new Map();\n  toRemove: Map<Key, ReusableView<T, V>> = new Map();\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CancelablePromise, easeOut, tween} from './tween';\nimport {Collection} from '@react-types/shared';\nimport {concatIterators, difference} from './utils';\nimport {\n  InvalidationContext,\n  ScrollAnchor,\n  ScrollToItemOptions,\n  VirtualizerDelegate,\n  VirtualizerOptions\n} from './types';\nimport {Key} from 'react';\nimport {Layout} from './Layout';\nimport {LayoutInfo} from './LayoutInfo';\nimport {OverscanManager} from './OverscanManager';\nimport {Point} from './Point';\nimport {Rect} from './Rect';\nimport {ReusableView} from './ReusableView';\nimport {Size} from './Size';\nimport {Transaction} from './Transaction';\n\n/**\n * The CollectionView class renders a scrollable collection of data using customizable layouts,\n * and manages animated updates to the data over time. It supports very large collections by\n * only rendering visible views to the DOM, reusing them as you scroll. Collection views can\n * present any type of view, including non-item views such as section headers and footers.\n * Optionally, the {@link EditableCollectionView} subclass can be used to enable user interaction\n * with the collection, including drag and drop, multiple selection, and keyboard interacton.\n *\n * Collection views get their data from a {@link DataSource} object that you provide. Items are\n * grouped into sections by the data source, and the collection view calls its methods to retrieve\n * the data. When data changes, the data source emits change events, and the collection view\n * updates as appropriate, optionally with an animated transition. There is one built-in data source\n * implementation, {@link ArrayDataSource}, which renders content from a 2d array.\n *\n * Collection views use {@link Layout} objects to compute what views should be visible, and how\n * to position and style them. This means that collection views can have their items arranged in\n * a stack, a grid, a circle, or any other layout you can think of. The layout can be changed\n * dynamically at runtime as well, optionally with an animated transition between the layouts.\n *\n * Layouts produce information on what views should appear in the collection view, but do not create\n * the views themselves directly. It is the responsibility of the {@link CollectionViewDelegate} object\n * to create instances of {@link ReusableView} subclasses which render the items into DOM nodes.\n * The delegate determines what type of view to display for each item, and creates instances of\n * views as needed by the collection view. Those views are then reused by the collection view as\n * the user scrolls through the content.\n */\nexport class Virtualizer<T extends object, V, W> {\n  /**\n   * The collection view delegate. The delegate is used by the collection view\n   * to create and configure views.\n   */\n  delegate: VirtualizerDelegate<T, V, W>;\n\n  /** The duration of animated layout changes, in milliseconds. Default is 500ms. */\n  transitionDuration: number;\n\n  /**\n   * Whether to enable scroll anchoring. This will attempt to restore the scroll position\n   * after layout changes outside the viewport. Default is off.\n   */\n  anchorScrollPosition: boolean;\n\n  /** Whether to anchor the scroll position when at the top of the content. Default is off. */\n  anchorScrollPositionAtTop: boolean;\n\n  /**\n   * Whether to overscan the visible area to pre-render items slightly outside and\n   * improve performance. Default is on.\n   */\n  shouldOverscan: boolean;\n\n  private _collection: Collection<T>;\n  private _layout: Layout<T>;\n  private _contentSize: Size;\n  private _visibleRect: Rect;\n  private _visibleLayoutInfos: Map<Key, LayoutInfo>;\n  private _reusableViews: {[type: string]: ReusableView<T, V>[]};\n  private _visibleViews: Map<Key, ReusableView<T, V>>;\n  private _renderedContent: WeakMap<T, V>;\n  private _children: Set<ReusableView<T, V>>;\n  private _invalidationContext: InvalidationContext<T, V> | null;\n  private _overscanManager: OverscanManager;\n  private _relayoutRaf: number | null;\n  private _scrollAnimation: CancelablePromise<void> | null;\n  private _isScrolling: boolean;\n  private _sizeUpdateQueue: Map<Key, Size>;\n  private _animatedContentOffset: Point;\n  private _transaction: Transaction<T, V> | null;\n  private _nextTransaction: Transaction<T, V> | null;\n  private _transactionQueue: Transaction<T, V>[];\n\n  constructor(options: VirtualizerOptions<T, V, W> = {}) {\n    this._contentSize = new Size;\n    this._visibleRect = new Rect;\n\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new OverscanManager();\n\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new Point(0, 0);\n\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n\n    // Set options from passed object if given\n    this.transitionDuration = options.transitionDuration ?? 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n    for (let key of ['delegate', 'size', 'layout', 'collection']) {\n      if (options[key]) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  _setContentSize(size: Size) {\n    this._contentSize = size;\n    this.delegate.setContentSize(size);\n  }\n\n  _setContentOffset(offset: Point) {\n    let rect = new Rect(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n    this.delegate.setVisibleRect(rect);\n  }\n\n  /**\n   * Get the size of the scrollable content.\n   */\n  get contentSize(): Size {\n    return this._contentSize;\n  }\n\n  /**\n   * Get the collection view's currently visible rectangle.\n   */\n  get visibleRect(): Rect {\n    return this._visibleRect;\n  }\n\n  /**\n   * Set the collection view's currently visible rectangle.\n   */\n  set visibleRect(rect: Rect) {\n    this._setVisibleRect(rect);\n  }\n\n  _setVisibleRect(rect: Rect, forceUpdate = false) {\n    let current = this._visibleRect;\n\n    // Ignore if the rects are equal\n    if (rect.equals(current)) {\n      return;\n    }\n\n    if (this.shouldOverscan) {\n      this._overscanManager.setVisibleRect(rect);\n    }\n\n    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n\n    this._resetAnimatedContentOffset();\n    this._visibleRect = rect;\n\n    if (shouldInvalidate) {\n      this.relayout({\n        offsetChanged: !rect.pointEquals(current),\n        sizeChanged: !rect.sizeEquals(current)\n      });\n    } else {\n      this.updateSubviews(forceUpdate);\n    }\n  }\n\n  get collection(): Collection<T> {\n    return this._collection;\n  }\n\n  set collection(data: Collection<T>) {\n    this._setData(data);\n  }\n\n  private _setData(data: Collection<T>) {\n    if (data === this._collection) {\n      return;\n    }\n\n    if (this._collection) {\n      this._runTransaction(() => {\n        this._collection = data;\n      }, this.transitionDuration > 0);\n    } else {\n      this._collection = data;\n      this.reloadData();\n    }\n  }\n\n  /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */\n  reloadData() {\n    this.relayout({\n      contentChanged: true\n    });\n  }\n\n  /**\n   * Returns the item with the given key.\n   */\n  getItem(key: Key) {\n    return this._collection ? this._collection.getItem(key) : null;\n  }\n\n  /**\n   * Get the collection view's layout.\n   */\n  get layout(): Layout<T> {\n    return this._layout;\n  }\n\n  /**\n   * Set the collection view's layout.\n   */\n  set layout(layout: Layout<T>) {\n    this.setLayout(layout);\n  }\n\n  /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */\n  setLayout(layout: Layout<T>, animated = false) {\n    if (layout === this._layout) {\n      return;\n    }\n\n    let applyLayout = () => {\n      if (this._layout) {\n        // @ts-ignore\n        this._layout.virtualizer = null;\n      }\n\n      layout.virtualizer = this;\n      this._layout = layout;\n    };\n\n    if (animated) {\n      // Animated layout transitions are really simple, thanks to our transaction support.\n      // We just set the layout inside a transaction action, which runs after the initial\n      // layout infos for the animation are retrieved from the previous layout. Then, the\n      // final layout infos are retrieved from the new layout, and animations occur.\n      this._runTransaction(applyLayout);\n    } else {\n      applyLayout();\n      this.relayout();\n    }\n  }\n\n  private _getReuseType(layoutInfo: LayoutInfo, content: T | null) {\n    if (layoutInfo.type === 'item' && content) {\n      let type = this.delegate.getType ? this.delegate.getType(content) : 'item';\n      let reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;\n      return {type, reuseType};\n    }\n\n    return {\n      type: layoutInfo.type,\n      reuseType: layoutInfo.type\n    };\n  }\n\n  getReusableView(layoutInfo: LayoutInfo): ReusableView<T, V> {\n    let content = this.getItem(layoutInfo.key);\n    let {reuseType} = this._getReuseType(layoutInfo, content);\n\n    if (!this._reusableViews[reuseType]) {\n      this._reusableViews[reuseType] = [];\n    }\n\n    let reusable = this._reusableViews[reuseType];\n    let view = reusable.length > 0\n      ? reusable.pop()\n      : new ReusableView<T, V>(this);\n\n    view.viewType = reuseType;\n\n    if (!this._animatedContentOffset.isOrigin()) {\n      layoutInfo = layoutInfo.copy();\n      layoutInfo.rect.x += this._animatedContentOffset.x;\n      layoutInfo.rect.y += this._animatedContentOffset.y;\n    }\n\n    view.layoutInfo = layoutInfo;\n\n    this._renderView(view);\n    return view;\n  }\n\n  private _renderView(reusableView: ReusableView<T, V>) {\n    let {type, key} = reusableView.layoutInfo;\n    reusableView.content = this.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n\n  private _renderContent(type: string, content: T) {\n    let cached = this._renderedContent.get(content);\n    if (cached != null) {\n      return cached;\n    }\n\n    let rendered = this.delegate.renderView(type, content);\n    if (content) {\n      this._renderedContent.set(content, rendered);\n    }\n    return rendered;\n  }\n\n  /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */\n  get visibleViews(): ReusableView<T, V>[] {\n    return Array.from(this._visibleViews.values());\n  }\n\n  /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */\n  getView(key: Key): ReusableView<T, V> | null {\n    return this._visibleViews.get(key) || null;\n  }\n\n  /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */\n  getViewsOfType(type: string): ReusableView<T, V>[] {\n    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);\n  }\n\n  /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */\n  keyForView(view: ReusableView<T, V>): Key | null {\n    if (view && view.layoutInfo) {\n      return view.layoutInfo.key;\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns the key for the item view currently at the given point.\n   */\n  keyAtPoint(point: Point): Key | null {\n    let rect = new Rect(point.x, point.y, 1, 1);\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n\n    let layoutInfo = layoutInfos[0];\n    if (!layoutInfo) {\n      return null;\n    }\n\n    return layoutInfo.key;\n  }\n\n  /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */\n  willUnmount() {\n    cancelAnimationFrame(this._relayoutRaf);\n  }\n\n  /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */\n  relayout(context: InvalidationContext<T, V> = {}) {\n    // Ignore relayouts while animating the scroll position\n    if (this._scrollAnimation || typeof requestAnimationFrame === 'undefined') {\n      return;\n    }\n\n    // If we already scheduled a relayout, extend the invalidation\n    // context so we coalesce multiple relayouts in the same frame.\n    if (this._invalidationContext) {\n      Object.assign(this._invalidationContext, context);\n      return;\n    }\n\n    this._invalidationContext = context;\n    this._relayoutRaf = requestAnimationFrame(() => {\n      this._relayoutRaf = null;\n      this.relayoutNow();\n    });\n  }\n\n  /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */\n  relayoutNow(context: InvalidationContext<T, V> = this._invalidationContext || {}) {\n    // Cancel the scheduled relayout, since we're doing it now.\n    if (this._relayoutRaf) {\n      cancelAnimationFrame(this._relayoutRaf);\n      this._relayoutRaf = null;\n    }\n\n    // Reset the invalidation context\n    this._invalidationContext = null;\n\n    // Do nothing if we don't have a layout or content, or we are\n    // in the middle of an animated scroll transition.\n    if (!this.layout || !this._collection || this._scrollAnimation) {\n      return;\n    }\n\n    let scrollAnchor = this._getScrollAnchor();\n\n    // Trigger the beforeLayout hook, if provided\n    if (typeof context.beforeLayout === 'function') {\n      context.beforeLayout();\n    }\n\n    // Validate the layout\n    this.layout.validate(context);\n    this._setContentSize(this.layout.getContentSize());\n\n    // Trigger the afterLayout hook, if provided\n    if (typeof context.afterLayout === 'function') {\n      context.afterLayout();\n    }\n\n    // Adjust scroll position based on scroll anchor, and constrain.\n    // If the content changed, scroll to the top.\n    let visibleRect = this.getVisibleRect();\n    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n\n    let hasLayoutUpdates = false;\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n      // Save the difference between the current and new content offsets, and apply it to the\n      // individual content items instead. At the end of the animation, we'll reset and set the\n      // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n      // the scroll animation and the content animation.\n      if (context.animated || !this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n        hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n      } else {\n        this._setContentOffset(new Point(contentOffsetX, contentOffsetY));\n      }\n    } else {\n      hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n    }\n\n    // Apply layout infos, unless this is coming from an animated transaction\n    if (!(context.transaction && context.animated)) {\n      this._applyLayoutInfos();\n    }\n\n    // Wait for animations, and apply the afterAnimation hook, if provided\n    if (context.animated && hasLayoutUpdates) {\n      this._enableTransitions();\n\n      let done = () => {\n        this._disableTransitions();\n\n        // Reset scroll position after animations (see above comment).\n        if (!this._animatedContentOffset.isOrigin()) {\n          // Get the content offset to scroll to, taking _animatedContentOffset into account.\n          let {x, y} = this.getVisibleRect();\n          this._resetAnimatedContentOffset();\n          this._setContentOffset(new Point(x, y));\n        }\n\n        if (typeof context.afterAnimation === 'function') {\n          context.afterAnimation();\n        }\n      };\n\n      // Sometimes the animation takes slightly longer than expected.\n      setTimeout(done, this.transitionDuration + 100);\n      return;\n    } else if (typeof context.afterAnimation === 'function') {\n      context.afterAnimation();\n    }\n  }\n\n  /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */\n  private _correctItemOrder() {\n    // Defer until after scrolling and animated transactions are complete\n    if (this._isScrolling || this._transaction) {\n      return;\n    }\n\n    for (let key of this._visibleLayoutInfos.keys()) {\n      let view = this._visibleViews.get(key);\n      this._children.delete(view);\n      this._children.add(view);\n    }\n  }\n\n  private _enableTransitions() {\n    this.delegate.beginAnimations();\n  }\n\n  private _disableTransitions() {\n    this.delegate.endAnimations();\n  }\n\n  private _getScrollAnchor(): ScrollAnchor | null {\n    if (!this.anchorScrollPosition) {\n      return null;\n    }\n\n    let visibleRect = this.getVisibleRect();\n\n    // Ask the delegate to provide a scroll anchor, if possible\n    if (this.delegate.getScrollAnchor) {\n      let key = this.delegate.getScrollAnchor(visibleRect);\n      if (key) {\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n        if (corner) {\n          let key = layoutInfo.key;\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          return {key, layoutInfo, corner, offset};\n        }\n      }\n    }\n\n    // No need to anchor the scroll position if it is at the top\n    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) {\n      return null;\n    }\n\n    // Find a view with a visible corner that has the smallest distance to the top of the collection view\n    let cornerAnchor: ScrollAnchor | null = null;\n\n    for (let [key, view] of this._visibleViews) {\n      let layoutInfo = view.layoutInfo;\n      if (layoutInfo && layoutInfo.rect.area > 0) {\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n        if (corner) {\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          if (!cornerAnchor || (offset < cornerAnchor.offset)) {\n            cornerAnchor = {key, layoutInfo, corner, offset};\n          }\n        }\n      }\n    }\n\n    return cornerAnchor;\n  }\n\n  private _restoreScrollAnchor(scrollAnchor: ScrollAnchor | null, context: InvalidationContext<T, V>) {\n    let contentOffset = this.getVisibleRect();\n\n    if (scrollAnchor) {\n      let finalAnchor = context.transaction?.animated\n        ? context.transaction.finalMap.get(scrollAnchor.key)\n        : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n\n      if (finalAnchor) {\n        let adjustment = (finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y) - scrollAnchor.offset;\n        contentOffset.y += adjustment;\n      }\n    }\n\n    return contentOffset;\n  }\n\n  getVisibleRect(): Rect {\n    let v = this.visibleRect;\n    let x = v.x - this._animatedContentOffset.x;\n    let y = v.y - this._animatedContentOffset.y;\n    return new Rect(x, y, v.width, v.height);\n  }\n\n  getVisibleLayoutInfos() {\n    let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n    return this._visibleLayoutInfos;\n  }\n\n  private _getLayoutInfoMap(rect: Rect, copy = false) {\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map;\n\n    for (let layoutInfo of layoutInfos) {\n      if (copy) {\n        layoutInfo = layoutInfo.copy();\n      }\n\n      map.set(layoutInfo.key, layoutInfo);\n    }\n\n    return map;\n  }\n\n  updateSubviews(forceUpdate = false) {\n    if (!this._collection) {\n      return;\n    }\n\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let currentlyVisible = this._visibleViews;\n    let toAdd, toRemove, toUpdate;\n\n    // If this is a force update, remove and re-add all views.\n    // Otherwise, find and update the diff.\n    if (forceUpdate) {\n      toAdd = visibleLayoutInfos;\n      toRemove = currentlyVisible;\n      toUpdate = new Set();\n    } else {\n      ({toAdd, toRemove, toUpdate} = difference(currentlyVisible, visibleLayoutInfos));\n\n      for (let key of toUpdate) {\n        let view = currentlyVisible.get(key);\n        if (!view || !view.layoutInfo) {\n          continue;\n        }\n\n        let item = this.getItem(visibleLayoutInfos.get(key).key);\n        if (view.content === item) {\n          toUpdate.delete(key);\n        } else {\n          // If the view type changes, delete and recreate the view instead of updating\n          let {reuseType} = this._getReuseType(view.layoutInfo, item);\n          if (view.viewType !== reuseType) {\n            toUpdate.delete(key);\n            toAdd.add(key);\n            toRemove.add(key);\n          }\n        }\n      }\n\n      // We are done if the sets are equal\n      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n        if (this._transaction) {\n          this._applyLayoutInfos();\n        }\n\n        return;\n      }\n    }\n\n    // Track views that should be removed. They are not removed from\n    // the DOM immediately, since we may reuse and need to re-insert\n    // them back into the DOM anyway.\n    let removed = new Set<ReusableView<T, V>>();\n\n    for (let key of toRemove.keys()) {\n      let view = this._visibleViews.get(key);\n      if (view) {\n        removed.add(view);\n        this._visibleViews.delete(key);\n\n        // If we are in the middle of a transaction, wait until the end\n        // of the animations to remove the views from the DOM. Also means\n        // we can't reuse those views immediately.\n        if (this._transaction) {\n          this._transaction.toRemove.set(key, view);\n        } else {\n          this.reuseView(view);\n        }\n      }\n    }\n\n    for (let key of toAdd.keys()) {\n      let layoutInfo = visibleLayoutInfos.get(key);\n      let view: ReusableView<T, V> | void;\n\n      // If we're in a transaction, and a layout change happens\n      // during the animations such that a view that was going\n      // to be removed is now not, we don't create a new view\n      // since the old one is still in the DOM, marked as toRemove.\n      if (this._transaction) {\n        // if transaction, get initial layout attributes for the animation\n        if (this._transaction.initialLayoutInfo.has(key)) {\n          layoutInfo = this._transaction.initialLayoutInfo.get(key);\n        }\n\n        view = this._transaction.toRemove.get(key);\n        if (view) {\n          this._transaction.toRemove.delete(key);\n          this._applyLayoutInfo(view, layoutInfo);\n        }\n      }\n\n      if (!view) {\n        // Create or reuse a view for this row\n        view = this.getReusableView(layoutInfo);\n\n        // Add the view to the DOM if needed\n        if (!removed.has(view)) {\n          this._children.add(view);\n        }\n      }\n\n      this._visibleViews.set(key, view);\n      removed.delete(view);\n    }\n\n    for (let key of toUpdate) {\n      let view = currentlyVisible.get(key) as ReusableView<T, V>;\n      this._renderedContent.delete(key);\n      this._renderView(view);\n    }\n\n    // Remove the remaining rows to delete from the DOM\n    if (!this._transaction) {\n      this.removeViews(removed);\n    }\n\n    this._correctItemOrder();\n    this._flushVisibleViews();\n\n    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n    if (hasLayoutUpdates) {\n      requestAnimationFrame(() => {\n        // If we're in a transaction, apply animations to visible views\n        // and \"to be removed\" views, which animate off screen.\n        if (this._transaction) {\n          requestAnimationFrame(() => this._applyLayoutInfos());\n        }\n      });\n    }\n\n    return hasLayoutUpdates;\n  }\n\n  afterRender() {\n    if (this.shouldOverscan) {\n      this._overscanManager.collectMetrics();\n    }\n  }\n\n  private _flushVisibleViews() {\n    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n    // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n    // method to build the final tree.\n    let viewsByParentKey = new Map([[null, []]]);\n    for (let view of this._children) {\n      if (!viewsByParentKey.has(view.layoutInfo.parentKey)) {\n        viewsByParentKey.set(view.layoutInfo.parentKey, []);\n      }\n\n      viewsByParentKey.get(view.layoutInfo.parentKey).push(view);\n      if (!viewsByParentKey.has(view.layoutInfo.key)) {\n        viewsByParentKey.set(view.layoutInfo.key, []);\n      }\n    }\n\n    let buildTree = (parent: ReusableView<T, V>, views: ReusableView<T, V>[]): W[] => views.map(view => {\n      let children = viewsByParentKey.get(view.layoutInfo.key);\n      return this.delegate.renderWrapper(\n        parent,\n        view,\n        children,\n        (childViews) => buildTree(view, childViews)\n      );\n    });\n\n    let children = buildTree(null, viewsByParentKey.get(null));\n    this.delegate.setVisibleViews(children);\n  }\n\n  private _applyLayoutInfo(view: ReusableView<T, V>, layoutInfo: LayoutInfo) {\n    if (view.layoutInfo === layoutInfo) {\n      return false;\n    }\n\n    view.layoutInfo = layoutInfo;\n    return true;\n  }\n\n  private _applyLayoutInfos() {\n    let updated = false;\n\n    // Apply layout infos to visible views\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (cur) {\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    // Apply final layout infos for views that will be removed\n    if (this._transaction) {\n      for (let view of this._transaction.toRemove.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n\n      for (let view of this._transaction.removed.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      this._flushVisibleViews();\n    }\n  }\n\n  private _hasLayoutUpdates() {\n    if (!this._transaction) {\n      return false;\n    }\n\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (!cur) {\n        return true;\n      }\n\n      let layoutInfo = this.layout.getLayoutInfo(cur.key);\n      if (\n        !cur.rect.pointEquals(layoutInfo.rect) ||\n        cur.opacity !== layoutInfo.opacity ||\n        cur.transform !== layoutInfo.transform\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  reuseView(view: ReusableView<T, V>) {\n    view.prepareForReuse();\n    this._reusableViews[view.viewType].push(view);\n  }\n\n  removeViews(toRemove: Set<ReusableView<T, V>>) {\n    for (let view of toRemove) {\n      this._children.delete(view);\n    }\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    // TODO: we should be able to invalidate a single index path\n    // @ts-ignore\n    if (!this.layout.updateItemSize) {\n      return;\n    }\n\n    // If the scroll position is currently animating, add the update\n    // to a queue to be processed after the animation is complete.\n    if (this._scrollAnimation) {\n      this._sizeUpdateQueue.set(key, size);\n      return;\n    }\n\n    // @ts-ignore\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) {\n      this.relayout();\n    }\n  }\n\n  startScrolling() {\n    this._isScrolling = true;\n  }\n\n  endScrolling() {\n    this._isScrolling = false;\n    this._correctItemOrder();\n    this._flushVisibleViews();\n  }\n\n  private _resetAnimatedContentOffset() {\n    // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n    if (!this._animatedContentOffset.isOrigin()) {\n      this._animatedContentOffset = new Point(0, 0);\n      this._applyLayoutInfos();\n    }\n  }\n\n  /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */\n  scrollToItem(key: Key, options?: ScrollToItemOptions) {\n    if (!key) {\n      return;\n    }\n\n    let layoutInfo = this.layout.getLayoutInfo(key);\n    if (!layoutInfo) {\n      return;\n    }\n\n    let {\n      duration = 300,\n      shouldScrollX = true,\n      shouldScrollY = true,\n      offsetX = 0,\n      offsetY = 0\n    } = options;\n\n    let x = this.visibleRect.x;\n    let y = this.visibleRect.y;\n    let minX = layoutInfo.rect.x - offsetX;\n    let minY = layoutInfo.rect.y - offsetY;\n    let maxX = x + this.visibleRect.width;\n    let maxY = y + this.visibleRect.height;\n\n    if (shouldScrollX) {\n      if (minX <= x || maxX === 0) {\n        x = minX;\n      } else if (layoutInfo.rect.maxX > maxX) {\n        x += layoutInfo.rect.maxX - maxX;\n      }\n    }\n\n    if (shouldScrollY) {\n      if (minY <= y || maxY === 0) {\n        y = minY;\n      } else if (layoutInfo.rect.maxY > maxY) {\n        y += layoutInfo.rect.maxY - maxY;\n      }\n    }\n\n    return this.scrollTo(new Point(x, y), duration);\n  }\n\n  /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */\n  scrollTo(offset: Point, duration: number = 300): Promise<void> {\n    // Cancel the current scroll animation\n    if (this._scrollAnimation) {\n      this._scrollAnimation.cancel();\n      this._scrollAnimation = null;\n    }\n\n    // Set the content offset synchronously if the duration is zero\n    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n      this._setContentOffset(offset);\n      return Promise.resolve();\n    }\n\n    this.startScrolling();\n\n    this._scrollAnimation = tween(this.visibleRect, offset, duration, easeOut, offset => {this._setContentOffset(offset);});\n    this._scrollAnimation.then(() => {\n      this._scrollAnimation = null;\n\n      // Process view size updates that occurred during the animation.\n      // Only views that are still visible will be actually updated.\n      for (let [key, size] of this._sizeUpdateQueue) {\n        this.updateItemSize(key, size);\n      }\n\n      this._sizeUpdateQueue.clear();\n      this.relayout();\n      this._processTransactionQueue();\n      this.endScrolling();\n    });\n\n    return this._scrollAnimation;\n  }\n\n  private _runTransaction(action: () => void, animated?: boolean) {\n    this._startTransaction();\n    if (this._nextTransaction) {\n      this._nextTransaction.actions.push(action);\n    }\n    this._endTransaction(animated);\n  }\n\n  private _startTransaction() {\n    if (!this._nextTransaction) {\n      this._nextTransaction = new Transaction;\n    }\n\n    this._nextTransaction.level++;\n  }\n\n  private _endTransaction(animated?: boolean) {\n    if (!this._nextTransaction) {\n      return false;\n    }\n\n    // Save whether the transaction should be animated.\n    if (animated != null) {\n      this._nextTransaction.animated = animated;\n    }\n\n    // If we haven't reached level 0, we are still in a\n    // nested transaction. Wait for the parent to end.\n    if (--this._nextTransaction.level > 0) {\n      return false;\n    }\n\n    // Do nothing for empty transactions\n    if (this._nextTransaction.actions.length === 0) {\n      this._nextTransaction = null;\n      return false;\n    }\n\n    // Default animations to true\n    if (this._nextTransaction.animated == null) {\n      this._nextTransaction.animated = true;\n    }\n\n    // Enqueue the transaction\n    this._transactionQueue.push(this._nextTransaction);\n    this._nextTransaction = null;\n\n    this._processTransactionQueue();\n    return true;\n  }\n\n  private _processTransactionQueue() {\n    // If the current transaction is animating, wait until the end\n    // to process the next transaction.\n    if (this._transaction || this._scrollAnimation) {\n      return;\n    }\n\n    let next = this._transactionQueue.shift();\n    if (next) {\n      this._performTransaction(next);\n    }\n  }\n\n  private _getContentRect(): Rect {\n    return new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n  }\n\n  private _performTransaction(transaction: Transaction<T, V>) {\n    this._transaction = transaction;\n\n    this.relayoutNow({\n      transaction: transaction,\n      animated: transaction.animated,\n\n      beforeLayout: () => {\n        // Get the initial layout infos for all views before the updates\n        // so we can figure out which views to add and remove.\n        if (transaction.animated) {\n          transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n        }\n\n        // Apply the actions that occurred during this transaction\n        for (let action of transaction.actions) {\n          action();\n        }\n      },\n\n      afterLayout: () => {\n        // Get the final layout infos after the updates\n        if (transaction.animated) {\n          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n          this._setupTransactionAnimations(transaction);\n        } else {\n          this._transaction = null;\n        }\n      },\n\n      afterAnimation: () => {\n        // Remove and reuse views when animations are done\n        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) {\n          for (let view of concatIterators(transaction.toRemove.values(), transaction.removed.values())) {\n            this._children.delete(view);\n            this.reuseView(view);\n          }\n        }\n\n        this._transaction = null;\n\n        // Ensure DOM order is correct for accessibility after animations are complete\n        this._correctItemOrder();\n        this._flushVisibleViews();\n\n        this._processTransactionQueue();\n      }\n    });\n  }\n\n  private _setupTransactionAnimations(transaction: Transaction<T, V>) {\n    let {initialMap, finalMap} = transaction;\n\n    // Store initial and final layout infos for animations\n    for (let [key, layoutInfo] of initialMap) {\n      if (finalMap.has(key)) {\n        // Store the initial layout info for use during animations.\n        transaction.initialLayoutInfo.set(key, layoutInfo);\n      } else {\n        // This view was removed. Store the layout info for use\n        // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n      }\n    }\n\n    // Get initial layout infos for views that were added\n    for (let [key, layoutInfo] of finalMap) {\n      if (!initialMap.has(key)) {\n        let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n        transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n      }\n    }\n\n    // Figure out which views were removed.\n    for (let [key, view] of this._visibleViews) {\n      if (!finalMap.has(key)) {\n        transaction.removed.set(key, view);\n        this._visibleViews.delete(key);\n\n        // In case something weird happened, where we have a view but no\n        // initial layout info, use the one attached to the view.\n        if (view.layoutInfo) {\n          if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) {\n            transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n          }\n        }\n      }\n    }\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection} from '@react-types/shared';\nimport {Key, useCallback, useEffect, useMemo, useState} from 'react';\nimport {Layout} from './Layout';\nimport {Rect} from './Rect';\nimport {ReusableView} from './ReusableView';\nimport {Size} from './Size';\nimport {useLayoutEffect} from '@react-aria/utils';\nimport {Virtualizer} from './Virtualizer';\n\ninterface VirtualizerProps<T extends object, V, W> {\n  renderView(type: string, content: T): V,\n  renderWrapper(\n    parent: ReusableView<T, V> | null,\n    reusableView: ReusableView<T, V>,\n    children: ReusableView<T, V>[],\n    renderChildren: (views: ReusableView<T, V>[]) => W[]\n  ): W,\n  layout: Layout<T>,\n  collection: Collection<T>,\n  onVisibleRectChange(rect: Rect): void,\n  getScrollAnchor?(rect: Rect): Key,\n  transitionDuration?: number\n}\n\nexport interface VirtualizerState<T extends object, V, W> {\n  visibleViews: W[],\n  setVisibleRect: (rect: Rect) => void,\n  contentSize: Size,\n  isAnimating: boolean,\n  virtualizer: Virtualizer<T, V, W>,\n  isScrolling: boolean,\n  startScrolling: () => void,\n  endScrolling: () => void\n}\n\nexport function useVirtualizerState<T extends object, V, W>(opts: VirtualizerProps<T, V, W>): VirtualizerState<T, V, W> {\n  let [visibleViews, setVisibleViews] = useState<W[]>([]);\n  let [contentSize, setContentSize] = useState(new Size());\n  let [isAnimating, setAnimating] = useState(false);\n  let [isScrolling, setScrolling] = useState(false);\n  let virtualizer = useMemo(() => new Virtualizer<T, V, W>(), []);\n\n  virtualizer.delegate = {\n    setVisibleViews,\n    setVisibleRect(rect) {\n      virtualizer.visibleRect = rect;\n      opts.onVisibleRectChange(rect);\n    },\n    setContentSize,\n    renderView: opts.renderView,\n    renderWrapper: opts.renderWrapper,\n    beginAnimations: () => setAnimating(true),\n    endAnimations: () => setAnimating(false),\n    getScrollAnchor: opts.getScrollAnchor\n  };\n\n  virtualizer.layout = opts.layout;\n  virtualizer.collection = opts.collection;\n  virtualizer.transitionDuration = opts.transitionDuration;\n\n  useLayoutEffect(() => {\n    virtualizer.afterRender();\n  });\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => virtualizer.willUnmount();\n  }, []);\n\n  return {\n    virtualizer,\n    visibleViews,\n    setVisibleRect: useCallback((rect) => {\n      virtualizer.visibleRect = rect;\n    }, [virtualizer]),\n    contentSize,\n    isAnimating,\n    isScrolling,\n    startScrolling: useCallback(() => {\n      virtualizer.startScrolling();\n      setScrolling(true);\n    }, [virtualizer]),\n    endScrolling: useCallback(() => {\n      virtualizer.endScrolling();\n      setScrolling(false);\n    }, [virtualizer])\n  };\n}\n"]},"metadata":{},"sourceType":"module"}