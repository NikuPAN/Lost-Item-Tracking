{"ast":null,"code":"import { useFocusable } from \"@react-aria/focus\";\nimport { useLocale } from \"@react-aria/i18n\";\nimport { useLabel } from \"@react-aria/label\";\nimport { setInteractionModality, useMove } from \"@react-aria/interactions\";\nimport { useRef, useCallback, useEffect } from \"react\";\nimport { clamp, mergeProps, useGlobalListeners, focusWithoutScrolling } from \"@react-aria/utils\";\nimport _babelRuntimeHelpersEsmExtends from \"@babel/runtime/helpers/esm/extends\";\nconst $d20491ae7743da17cfa841ff6d87$export$sliderIds = new WeakMap();\n\nfunction $d20491ae7743da17cfa841ff6d87$export$getSliderThumbId(state, index) {\n  let id = $d20491ae7743da17cfa841ff6d87$export$sliderIds.get(state);\n\n  if (!id) {\n    throw new Error('Unknown slider state');\n  }\n\n  return id + \"-\" + index;\n}\n/**\n * Provides the behavior and accessibility implementation for a slider component representing one or more values.\n *\n * @param props Props for the slider.\n * @param state State for the slider, as returned by `useSliderState`.\n * @param trackRef Ref for the \"track\" element.  The width of this element provides the \"length\"\n * of the track -- the span of one dimensional space that the slider thumb can be.  It also\n * accepts click and drag motions, so that the closest thumb will follow clicks and drags on\n * the track.\n */\n\n\nexport function useSlider(props, state, trackRef) {\n  var _labelProps$id;\n\n  let {\n    labelProps,\n    fieldProps\n  } = useLabel(props);\n  let isVertical = props.orientation === 'vertical'; // Attach id of the label to the state so it can be accessed by useSliderThumb.\n\n  $d20491ae7743da17cfa841ff6d87$export$sliderIds.set(state, (_labelProps$id = labelProps.id) != null ? _labelProps$id : fieldProps.id);\n  let {\n    direction\n  } = useLocale();\n  let {\n    addGlobalListener,\n    removeGlobalListener\n  } = useGlobalListeners(); // When the user clicks or drags the track, we want the motion to set and drag the\n  // closest thumb.  Hence we also need to install useMove() on the track element.\n  // Here, we keep track of which index is the \"closest\" to the drag start point.\n  // It is set onMouseDown/onTouchDown; see trackProps below.\n\n  const realTimeTrackDraggingIndex = useRef(null);\n  const stateRef = useRef(null);\n  stateRef.current = state;\n  const reverseX = direction === 'rtl';\n  const currentPosition = useRef(null);\n  const {\n    moveProps\n  } = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n    },\n\n    onMove(_ref) {\n      let {\n        deltaX,\n        deltaY\n      } = _ref;\n      let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = stateRef.current.getThumbPercent(realTimeTrackDraggingIndex.current) * size;\n      }\n\n      let delta = isVertical ? deltaY : deltaX;\n\n      if (isVertical || reverseX) {\n        delta = -delta;\n      }\n\n      currentPosition.current += delta;\n\n      if (realTimeTrackDraggingIndex.current != null && trackRef.current) {\n        const percent = clamp(currentPosition.current / size, 0, 1);\n        stateRef.current.setThumbPercent(realTimeTrackDraggingIndex.current, percent);\n      }\n    },\n\n    onMoveEnd() {\n      if (realTimeTrackDraggingIndex.current != null) {\n        stateRef.current.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n\n  });\n  let currentPointer = useRef(undefined);\n\n  let onDownTrack = (e, id, clientX, clientY) => {\n    // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.\n    if (trackRef.current && !props.isDisabled && state.values.every((_, i) => !state.isThumbDragging(i))) {\n      let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth; // Find the closest thumb\n\n      const trackPosition = trackRef.current.getBoundingClientRect()[isVertical ? 'top' : 'left'];\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n\n      if (direction === 'rtl' || isVertical) {\n        percent = 1 - percent;\n      }\n\n      let value = state.getPercentValue(percent); // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n\n      let closestThumb;\n      let split = state.values.findIndex(v => value - v < 0);\n\n      if (split === 0) {\n        // If the index is zero then the closetThumb is the first one\n        closestThumb = split;\n      } else if (split === -1) {\n        // If no index is found they've clicked past all the thumbs\n        closestThumb = state.values.length - 1;\n      } else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split]; // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) {\n          closestThumb = split - 1;\n        } else {\n          closestThumb = split;\n        }\n      } // Confirm that the found closest thumb is editable, not disabled, and move it\n\n\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n        realTimeTrackDraggingIndex.current = closestThumb;\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, true);\n        state.setThumbValue(closestThumb, value);\n        addGlobalListener(window, 'mouseup', onUpTrack, false);\n        addGlobalListener(window, 'touchend', onUpTrack, false);\n        addGlobalListener(window, 'pointerup', onUpTrack, false);\n      } else {\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  };\n\n  let onUpTrack = e => {\n    var _e$pointerId, _e$changedTouches;\n\n    let id = (_e$pointerId = e.pointerId) != null ? _e$pointerId : (_e$changedTouches = e.changedTouches) == null ? void 0 : _e$changedTouches[0].identifier;\n\n    if (id === currentPointer.current) {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n\n      removeGlobalListener(window, 'mouseup', onUpTrack, false);\n      removeGlobalListener(window, 'touchend', onUpTrack, false);\n      removeGlobalListener(window, 'pointerup', onUpTrack, false);\n    }\n  };\n\n  if (labelProps.htmlFor) {\n    // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS\n    // causes this to override the `aria-labelledby` on the thumb. This causes the first\n    // thumb to only be announced as the slider label rather than its individual name as well.\n    // See https://bugs.webkit.org/show_bug.cgi?id=172464.\n    delete labelProps.htmlFor;\n\n    labelProps.onClick = () => {\n      var _document$getElementB; // Safari does not focus <input type=\"range\"> elements when clicking on an associated <label>,\n      // so do it manually. In addition, make sure we show the focus ring.\n\n\n      (_document$getElementB = document.getElementById($d20491ae7743da17cfa841ff6d87$export$getSliderThumbId(state, 0))) == null ? void 0 : _document$getElementB.focus();\n      setInteractionModality('keyboard');\n    };\n  }\n\n  return {\n    labelProps,\n    // The root element of the Slider will have role=\"group\" to group together\n    // all the thumb inputs in the Slider.  The label of the Slider will\n    // be used to label the group.\n    groupProps: _babelRuntimeHelpersEsmExtends({\n      role: 'group'\n    }, fieldProps),\n    trackProps: mergeProps({\n      onMouseDown(e) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n\n        onDownTrack(e, undefined, e.clientX, e.clientY);\n      },\n\n      onPointerDown(e) {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) {\n          return;\n        }\n\n        onDownTrack(e, e.pointerId, e.clientX, e.clientY);\n      },\n\n      onTouchStart(e) {\n        onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n      }\n\n    }, moveProps),\n    outputProps: {\n      htmlFor: state.values.map((_, index) => $d20491ae7743da17cfa841ff6d87$export$getSliderThumbId(state, index)).join(' '),\n      'aria-live': 'off'\n    }\n  };\n}\n/**\n * Provides behavior and accessibility for a thumb of a slider component.\n *\n * @param opts Options for this Slider thumb.\n * @param state Slider state, created via `useSliderState`.\n */\n\nexport function useSliderThumb(opts, state) {\n  var _opts$ariaLabelledby;\n\n  let {\n    index,\n    isRequired,\n    isDisabled,\n    validationState,\n    trackRef,\n    inputRef\n  } = opts;\n  let isVertical = opts.orientation === 'vertical';\n  let {\n    direction\n  } = useLocale();\n  let {\n    addGlobalListener,\n    removeGlobalListener\n  } = useGlobalListeners();\n  let labelId = $d20491ae7743da17cfa841ff6d87$export$sliderIds.get(state);\n  const {\n    labelProps,\n    fieldProps\n  } = useLabel(_babelRuntimeHelpersEsmExtends({}, opts, {\n    id: $d20491ae7743da17cfa841ff6d87$export$getSliderThumbId(state, index),\n    'aria-labelledby': (labelId + \" \" + ((_opts$ariaLabelledby = opts['aria-labelledby']) != null ? _opts$ariaLabelledby : '')).trim()\n  }));\n  const value = state.values[index];\n  const focusInput = useCallback(() => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n  const isFocused = state.focusedThumb === index;\n  useEffect(() => {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n  const stateRef = useRef(null);\n  stateRef.current = state;\n  let reverseX = direction === 'rtl';\n  let currentPosition = useRef(null);\n  let {\n    moveProps\n  } = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n\n    onMove(_ref) {\n      let {\n        deltaX,\n        deltaY,\n        pointerType\n      } = _ref;\n      let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = stateRef.current.getThumbPercent(index) * size;\n      }\n\n      if (pointerType === 'keyboard') {\n        // (invert left/right according to language direction) + (according to vertical)\n        let delta = ((reverseX ? -deltaX : deltaX) + (isVertical ? -deltaY : -deltaY)) * stateRef.current.step;\n        currentPosition.current += delta * size;\n        stateRef.current.setThumbValue(index, stateRef.current.getThumbValue(index) + delta);\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n\n        if (isVertical || reverseX) {\n          delta = -delta;\n        }\n\n        currentPosition.current += delta;\n        stateRef.current.setThumbPercent(index, clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    }\n\n  }); // Immediately register editability with the state\n\n  state.setThumbEditable(index, !isDisabled);\n  const {\n    focusableProps\n  } = useFocusable(mergeProps(opts, {\n    onFocus: () => state.setFocusedThumb(index),\n    onBlur: () => state.setFocusedThumb(undefined)\n  }), inputRef);\n  let currentPointer = useRef(undefined);\n\n  let onDown = id => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n  };\n\n  let onUp = e => {\n    var _e$pointerId, _e$changedTouches;\n\n    let id = (_e$pointerId = e.pointerId) != null ? _e$pointerId : (_e$changedTouches = e.changedTouches) == null ? void 0 : _e$changedTouches[0].identifier;\n\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  }; // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n\n\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      type: 'range',\n      tabIndex: !isDisabled ? 0 : undefined,\n      min: state.getThumbMinValue(index),\n      max: state.getThumbMaxValue(index),\n      step: state.step,\n      value: value,\n      disabled: isDisabled,\n      'aria-orientation': opts.orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      onChange: e => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: !isDisabled ? mergeProps(moveProps, {\n      onMouseDown: e => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n\n        onDown(null);\n      },\n      onPointerDown: e => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n\n        onDown(e.pointerId);\n      },\n      onTouchStart: e => {\n        onDown(e.changedTouches[0].identifier);\n      }\n    }) : {},\n    labelProps\n  };\n}","map":{"version":3,"sources":["packages/@react-aria/slider/src/utils.ts","packages/@react-aria/slider/src/useSlider.ts","packages/@react-aria/slider/src/useSliderThumb.ts"],"names":["sliderIds","id","fieldProps","useLabel","isVertical","props","labelProps","direction","useLocale","removeGlobalListener","useGlobalListeners","realTimeTrackDraggingIndex","useRef","stateRef","reverseX","currentPosition","moveProps","useMove","onMoveStart","onMove","deltaY","size","trackRef","delta","percent","clamp","onMoveEnd","currentPointer","onDownTrack","state","trackPosition","clickPosition","offset","value","split","v","closestThumb","lastLeft","firstRight","Math","e","addGlobalListener","onUpTrack","setInteractionModality","groupProps","role","trackProps","mergeProps","onMouseDown","onPointerDown","onTouchStart","outputProps","htmlFor","inputRef","opts","labelId","focusInput","useCallback","focusWithoutScrolling","isFocused","useEffect","pointerType","focusableProps","useFocusable","onFocus","onBlur","onDown","onUp","inputProps","type","tabIndex","min","max","step","disabled","isRequired","validationState","onChange","parseFloat","thumbProps"],"mappings":"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","sourcesContent":["import {SliderState} from '@react-stately/slider';\n\nexport const sliderIds = new WeakMap<SliderState, string>();\n\nexport function getSliderThumbId(state: SliderState, index: number) {\n  let id = sliderIds.get(state);\n  if (!id) {\n    throw new Error('Unknown slider state');\n  }\n\n  return `${id}-${index}`;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaSliderProps} from '@react-types/slider';\nimport {clamp, mergeProps, useGlobalListeners} from '@react-aria/utils';\nimport {getSliderThumbId, sliderIds} from './utils';\nimport React, {HTMLAttributes, LabelHTMLAttributes, OutputHTMLAttributes, RefObject, useRef} from 'react';\nimport {setInteractionModality, useMove} from '@react-aria/interactions';\nimport {SliderState} from '@react-stately/slider';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\ninterface SliderAria {\n  /** Props for the label element. */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n\n  /** Props for the root element of the slider component; groups slider inputs. */\n  groupProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the track element. */\n  trackProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the output element, displaying the value of the slider thumbs. */\n  outputProps: OutputHTMLAttributes<HTMLOutputElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a slider component representing one or more values.\n *\n * @param props Props for the slider.\n * @param state State for the slider, as returned by `useSliderState`.\n * @param trackRef Ref for the \"track\" element.  The width of this element provides the \"length\"\n * of the track -- the span of one dimensional space that the slider thumb can be.  It also\n * accepts click and drag motions, so that the closest thumb will follow clicks and drags on\n * the track.\n */\nexport function useSlider(\n  props: AriaSliderProps,\n  state: SliderState,\n  trackRef: RefObject<HTMLElement>\n): SliderAria {\n  let {labelProps, fieldProps} = useLabel(props);\n\n  let isVertical = props.orientation === 'vertical';\n\n  // Attach id of the label to the state so it can be accessed by useSliderThumb.\n  sliderIds.set(state, labelProps.id ?? fieldProps.id);\n\n  let {direction} = useLocale();\n\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  // When the user clicks or drags the track, we want the motion to set and drag the\n  // closest thumb.  Hence we also need to install useMove() on the track element.\n  // Here, we keep track of which index is the \"closest\" to the drag start point.\n  // It is set onMouseDown/onTouchDown; see trackProps below.\n  const realTimeTrackDraggingIndex = useRef<number | null>(null);\n\n  const stateRef = useRef<SliderState>(null);\n  stateRef.current = state;\n  const reverseX = direction === 'rtl';\n  const currentPosition = useRef<number>(null);\n  const {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n    },\n    onMove({deltaX, deltaY}) {\n      let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = stateRef.current.getThumbPercent(realTimeTrackDraggingIndex.current) * size;\n      }\n\n      let delta = isVertical ? deltaY : deltaX;\n      if (isVertical || reverseX) {\n        delta = -delta;\n      }\n\n      currentPosition.current += delta;\n\n      if (realTimeTrackDraggingIndex.current != null && trackRef.current) {\n        const percent = clamp(currentPosition.current / size, 0, 1);\n        stateRef.current.setThumbPercent(realTimeTrackDraggingIndex.current, percent);\n      }\n    },\n    onMoveEnd() {\n      if (realTimeTrackDraggingIndex.current != null) {\n        stateRef.current.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  });\n\n  let currentPointer = useRef<number | null | undefined>(undefined);\n  let onDownTrack = (e: React.UIEvent, id: number, clientX: number, clientY: number) => {\n    // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.\n    if (trackRef.current && !props.isDisabled && state.values.every((_, i) => !state.isThumbDragging(i))) {\n      let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth;\n      // Find the closest thumb\n      const trackPosition = trackRef.current.getBoundingClientRect()[isVertical ? 'top' : 'left'];\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (direction === 'rtl' || isVertical) {\n        percent = 1 - percent;\n      }\n      let value = state.getPercentValue(percent);\n\n      // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n      let closestThumb;\n      let split = state.values.findIndex(v => value - v < 0);\n      if (split === 0) { // If the index is zero then the closetThumb is the first one\n        closestThumb = split;\n      } else if (split === -1) { // If no index is found they've clicked past all the thumbs\n        closestThumb = state.values.length - 1;\n      } else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split];\n        // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) {\n          closestThumb = split - 1;\n        } else {\n          closestThumb = split;\n        }\n      }\n\n      // Confirm that the found closest thumb is editable, not disabled, and move it\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n\n        realTimeTrackDraggingIndex.current = closestThumb;\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, true);\n        state.setThumbValue(closestThumb, value);\n\n        addGlobalListener(window, 'mouseup', onUpTrack, false);\n        addGlobalListener(window, 'touchend', onUpTrack, false);\n        addGlobalListener(window, 'pointerup', onUpTrack, false);\n      } else {\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  };\n\n  let onUpTrack = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n\n      removeGlobalListener(window, 'mouseup', onUpTrack, false);\n      removeGlobalListener(window, 'touchend', onUpTrack, false);\n      removeGlobalListener(window, 'pointerup', onUpTrack, false);\n    }\n  };\n\n  if (labelProps.htmlFor) {\n    // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS\n    // causes this to override the `aria-labelledby` on the thumb. This causes the first\n    // thumb to only be announced as the slider label rather than its individual name as well.\n    // See https://bugs.webkit.org/show_bug.cgi?id=172464.\n    delete labelProps.htmlFor;\n    labelProps.onClick = () => {\n      // Safari does not focus <input type=\"range\"> elements when clicking on an associated <label>,\n      // so do it manually. In addition, make sure we show the focus ring.\n      document.getElementById(getSliderThumbId(state, 0))?.focus();\n      setInteractionModality('keyboard');\n    };\n  }\n\n  return {\n    labelProps,\n    // The root element of the Slider will have role=\"group\" to group together\n    // all the thumb inputs in the Slider.  The label of the Slider will\n    // be used to label the group.\n    groupProps: {\n      role: 'group',\n      ...fieldProps\n    },\n    trackProps: mergeProps({\n      onMouseDown(e: React.MouseEvent<HTMLElement>) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDownTrack(e, undefined, e.clientX, e.clientY);\n      },\n      onPointerDown(e: React.PointerEvent<HTMLElement>) {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) {\n          return;\n        }\n        onDownTrack(e, e.pointerId, e.clientX, e.clientY);\n      },\n      onTouchStart(e: React.TouchEvent<HTMLElement>) { onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY); }\n    }, moveProps),\n    outputProps: {\n      htmlFor: state.values.map((_, index) => getSliderThumbId(state, index)).join(' '),\n      'aria-live': 'off'\n    }\n  };\n}\n","import {AriaSliderThumbProps} from '@react-types/slider';\nimport {clamp, focusWithoutScrolling, mergeProps, useGlobalListeners} from '@react-aria/utils';\nimport {getSliderThumbId, sliderIds} from './utils';\nimport React, {ChangeEvent, HTMLAttributes, InputHTMLAttributes, LabelHTMLAttributes, RefObject, useCallback, useEffect, useRef} from 'react';\nimport {SliderState} from '@react-stately/slider';\nimport {useFocusable} from '@react-aria/focus';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\nimport {useMove} from '@react-aria/interactions';\n\ninterface SliderThumbAria {\n  /** Props for the root thumb element; handles the dragging motion. */\n  thumbProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the range input. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>,\n\n  /** Props for the label element for this thumb. */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>\n}\n\ninterface SliderThumbOptions extends AriaSliderThumbProps {\n  /** A ref to the track element. */\n  trackRef: RefObject<HTMLElement>,\n  /** A ref to the thumb input element. */\n  inputRef: RefObject<HTMLInputElement>\n}\n\n/**\n * Provides behavior and accessibility for a thumb of a slider component.\n *\n * @param opts Options for this Slider thumb.\n * @param state Slider state, created via `useSliderState`.\n */\nexport function useSliderThumb(\n  opts: SliderThumbOptions,\n  state: SliderState\n): SliderThumbAria {\n  let {\n    index,\n    isRequired,\n    isDisabled,\n    validationState,\n    trackRef,\n    inputRef\n  } = opts;\n\n  let isVertical = opts.orientation === 'vertical';\n\n  let {direction} = useLocale();\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  let labelId = sliderIds.get(state);\n  const {labelProps, fieldProps} = useLabel({\n    ...opts,\n    id: getSliderThumbId(state, index),\n    'aria-labelledby': `${labelId} ${opts['aria-labelledby'] ?? ''}`.trim()\n  });\n\n  const value = state.values[index];\n\n  const focusInput = useCallback(() => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n\n  const isFocused = state.focusedThumb === index;\n\n  useEffect(() => {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n\n  const stateRef = useRef<SliderState>(null);\n  stateRef.current = state;\n  let reverseX = direction === 'rtl';\n  let currentPosition = useRef<number>(null);\n  let {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n    onMove({deltaX, deltaY, pointerType}) {\n      let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = stateRef.current.getThumbPercent(index) * size;\n      }\n      if (pointerType === 'keyboard') {\n        // (invert left/right according to language direction) + (according to vertical)\n        let delta = ((reverseX ? -deltaX : deltaX) + (isVertical ? -deltaY : -deltaY)) * stateRef.current.step;\n        currentPosition.current += delta * size;\n        stateRef.current.setThumbValue(index, stateRef.current.getThumbValue(index) + delta);\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) {\n          delta = -delta;\n        }\n\n        currentPosition.current += delta;\n        stateRef.current.setThumbPercent(index, clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    }\n  });\n\n  // Immediately register editability with the state\n  state.setThumbEditable(index, !isDisabled);\n\n  const {focusableProps} = useFocusable(\n    mergeProps(opts, {\n      onFocus: () => state.setFocusedThumb(index),\n      onBlur: () => state.setFocusedThumb(undefined)\n    }),\n    inputRef\n  );\n\n  let currentPointer = useRef<number | null | undefined>(undefined);\n  let onDown = (id: number | null) => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n\n  };\n\n  let onUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      type: 'range',\n      tabIndex: !isDisabled ? 0 : undefined,\n      min: state.getThumbMinValue(index),\n      max: state.getThumbMaxValue(index),\n      step: state.step,\n      value: value,\n      disabled: isDisabled,\n      'aria-orientation': opts.orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      onChange: (e: ChangeEvent<HTMLInputElement>) => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: !isDisabled ? mergeProps(\n      moveProps,\n      {\n        onMouseDown: (e: React.MouseEvent<HTMLElement>) => {\n          if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n            return;\n          }\n          onDown(null);\n        },\n        onPointerDown: (e: React.PointerEvent<HTMLElement>) => {\n          if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n            return;\n          }\n          onDown(e.pointerId);\n        },\n        onTouchStart: (e: React.TouchEvent<HTMLElement>) => {onDown(e.changedTouches[0].identifier);}\n      }\n    ) : {},\n    labelProps\n  };\n}\n"]},"metadata":{},"sourceType":"module"}