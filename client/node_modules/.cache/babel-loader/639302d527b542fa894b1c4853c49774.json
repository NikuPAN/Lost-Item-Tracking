{"ast":null,"code":"import { useControlledState } from \"@react-stately/utils\";\nimport { useCollection } from \"@react-stately/collections\";\nimport { SelectionManager, useMultipleSelectionState } from \"@react-stately/selection\";\nimport { useEffect, useMemo } from \"react\";\nlet $afa6f708e32ecf7f97d9a58dfd59c$var$_Symbol$iterator;\n$afa6f708e32ecf7f97d9a58dfd59c$var$_Symbol$iterator = Symbol.iterator;\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $afa6f708e32ecf7f97d9a58dfd59c$export$TreeCollection {\n  constructor(nodes, _temp) {\n    var _last;\n\n    let {\n      expandedKeys\n    } = _temp === void 0 ? {} : _temp;\n    this.keyMap = new Map();\n    this.iterable = void 0;\n    this.firstKey = void 0;\n    this.lastKey = void 0;\n    this.iterable = nodes;\n    expandedKeys = expandedKeys || new Set();\n\n    let visit = node => {\n      this.keyMap.set(node.key, node);\n\n      if (node.childNodes && (node.type === 'section' || expandedKeys.has(node.key))) {\n        for (let child of node.childNodes) {\n          visit(child);\n        }\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let last;\n    let index = 0;\n\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n\n      if (node.type === 'item') {\n        node.index = index++;\n      }\n\n      last = node; // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n\n      last.nextKey = undefined;\n    }\n\n    this.lastKey = (_last = last) == null ? void 0 : _last.key;\n  }\n\n  *[$afa6f708e32ecf7f97d9a58dfd59c$var$_Symbol$iterator]() {\n    yield* this.iterable;\n  }\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    return this.lastKey;\n  }\n\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n\n}\n/**\n * Provides state management for tree-like components. Handles building a collection\n * of items from props, item expanded state, and manages multiple selection state.\n */\n\n\nexport function useTreeState(props) {\n  let [expandedKeys, setExpandedKeys] = useControlledState(props.expandedKeys ? new Set(props.expandedKeys) : undefined, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(), props.onExpandedChange);\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let tree = useCollection(props, nodes => new $afa6f708e32ecf7f97d9a58dfd59c$export$TreeCollection(nodes, {\n    expandedKeys\n  })); // Reset focused key if that item is deleted from the collection.\n\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) {\n      selectionState.setFocusedKey(null);\n    }\n  }, [tree, selectionState.focusedKey]);\n\n  let onToggle = key => {\n    setExpandedKeys(expandedKeys => $f51dc3c5c900bd3cdb4a06df11d84697$var$toggleKey(expandedKeys, key));\n  };\n\n  return {\n    collection: tree,\n    expandedKeys,\n    disabledKeys,\n    toggleKey: onToggle,\n    selectionManager: new SelectionManager(tree, selectionState)\n  };\n}\n\nfunction $f51dc3c5c900bd3cdb4a06df11d84697$var$toggleKey(set, key) {\n  let res = new Set(set);\n\n  if (res.has(key)) {\n    res.delete(key);\n  } else {\n    res.add(key);\n  }\n\n  return res;\n}","map":{"version":3,"sources":["packages/@react-stately/tree/src/TreeCollection.ts","packages/@react-stately/tree/src/useTreeState.ts"],"names":["keyMap","iterable","firstKey","lastKey","constructor","expandedKeys","visit","node","index","last","Symbol","iterator","getKeys","getKeyBefore","getKeyAfter","getFirstKey","getLastKey","getItem","useControlledState","props","selectionState","useMultipleSelectionState","disabledKeys","useMemo","tree","useCollection","nodes","useEffect","onToggle","key","setExpandedKeys","toggleKey","collection","selectionManager","res"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, Node} from '@react-types/shared';\nimport {Key} from 'react';\n\nexport class TreeCollection<T> implements Collection<Node<T>> {\n  private keyMap: Map<Key, Node<T>> = new Map();\n  private iterable: Iterable<Node<T>>;\n  private firstKey: Key;\n  private lastKey: Key;\n\n  constructor(nodes: Iterable<Node<T>>, {expandedKeys}: {expandedKeys?: Set<Key>} = {}) {\n    this.iterable = nodes;\n    expandedKeys = expandedKeys || new Set();\n\n    let visit = (node: Node<T>) => {\n      this.keyMap.set(node.key, node);\n\n      if (node.childNodes && (node.type === 'section' || expandedKeys.has(node.key))) {\n        for (let child of node.childNodes) {\n          visit(child);\n        }\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let last: Node<T>;\n    let index = 0;\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n\n      if (node.type === 'item') {\n        node.index = index++;\n      }\n\n      last = node;\n\n      // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n      last.nextKey = undefined;\n    }\n\n    this.lastKey = last?.key;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.iterable;\n  }\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    return this.lastKey;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, CollectionBase, Expandable, MultipleSelection, Node} from '@react-types/shared';\nimport {Key, useEffect, useMemo} from 'react';\nimport {SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\nimport {TreeCollection} from './TreeCollection';\nimport {useCollection} from '@react-stately/collections';\nimport {useControlledState} from '@react-stately/utils';\n\ninterface TreeProps<T> extends CollectionBase<T>, Expandable, MultipleSelection {}\nexport interface TreeState<T> {\n  /** A collection of items in the tree. */\n  readonly collection: Collection<Node<T>>,\n\n  /** A set of keys for items that are disabled. */\n  readonly disabledKeys: Set<Key>,\n\n  /** A set of keys for items that are expanded. */\n  readonly expandedKeys: Set<Key>,\n\n  /** Toggles the expanded state for an item by its key. */\n  toggleKey(key: Key): void,\n\n  /** A selection manager to read and update multiple selection state. */\n  readonly selectionManager: SelectionManager\n}\n\n/**\n * Provides state management for tree-like components. Handles building a collection\n * of items from props, item expanded state, and manages multiple selection state.\n */\nexport function useTreeState<T extends object>(props: TreeProps<T>): TreeState<T> {\n  let [expandedKeys, setExpandedKeys] = useControlledState(\n    props.expandedKeys ? new Set(props.expandedKeys) : undefined,\n    props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(),\n    props.onExpandedChange\n  );\n\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n\n  let tree = useCollection(props, nodes => new TreeCollection(nodes, {expandedKeys}));\n\n  // Reset focused key if that item is deleted from the collection.\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) {\n      selectionState.setFocusedKey(null);\n    }\n  }, [tree, selectionState.focusedKey]);\n\n  let onToggle = (key: Key) => {\n    setExpandedKeys(expandedKeys => toggleKey(expandedKeys, key));\n  };\n\n  return {\n    collection: tree,\n    expandedKeys,\n    disabledKeys,\n    toggleKey: onToggle,\n    selectionManager: new SelectionManager(tree, selectionState)\n  };\n}\n\nfunction toggleKey(set: Set<Key>, key: Key): Set<Key> {\n  let res = new Set(set);\n  if (res.has(key)) {\n    res.delete(key);\n  } else {\n    res.add(key);\n  }\n\n  return res;\n}\n"]},"metadata":{},"sourceType":"module"}