{"ast":null,"code":"import { useCollator } from \"@react-aria/i18n\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { focusSafely, getFocusableTreeWalker } from \"@react-aria/focus\";\nimport { useEffect, useRef, useMemo } from \"react\";\nimport _babelRuntimeHelpersEsmExtends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * Handles typeahead interactions with collections.\n */\n\nexport function useTypeSelect(options) {\n  let {\n    keyboardDelegate,\n    selectionManager,\n    onTypeSelect\n  } = options;\n  let state = useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  let onKeyDown = e => {\n    let character = $c78d7fa5f7d5832f9b4f97b33a679865$var$getStringForKey(e.key);\n\n    if (!character || e.ctrlKey || e.metaKey) {\n      return;\n    } // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n\n\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    state.search += character; // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey); // If no key found, search from the top.\n\n    if (key == null) {\n      key = keyboardDelegate.getKeyForSearch(state.search);\n    }\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n\n      if (onTypeSelect) {\n        onTypeSelect(key);\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, 500);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction $c78d7fa5f7d5832f9b4f97b33a679865$var$getStringForKey(key) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n\nconst $a9b9aa71af07c56ab1d89ca45381f4b$var$isMac = typeof window !== 'undefined' && window.navigator != null ? /^Mac/.test(window.navigator.platform) : false;\n\nfunction $a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) {\n  if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isMac) {\n    return e.metaKey;\n  }\n\n  return e.ctrlKey;\n}\n/**\n * Handles interactions with selectable collections.\n */\n\n\nexport function useSelectableCollection(options) {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = false,\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus\n  } = options;\n\n  let onKeyDown = e => {\n    // Let child element (e.g. menu button) handle the event if the Alt key is pressed.\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (e.altKey || !ref.current.contains(e.target)) {\n      return;\n    }\n\n    switch (e.key) {\n      case 'ArrowDown':\n        {\n          if (delegate.getKeyBelow) {\n            e.preventDefault();\n            let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : delegate.getFirstKey();\n\n            if (nextKey != null) {\n              manager.setFocusedKey(nextKey);\n\n              if (manager.selectionMode === 'single' && selectOnFocus) {\n                manager.replaceSelection(nextKey);\n              }\n            } else if (shouldFocusWrap) {\n              let wrapKey = delegate.getFirstKey(manager.focusedKey);\n              manager.setFocusedKey(wrapKey);\n\n              if (manager.selectionMode === 'single' && selectOnFocus) {\n                manager.replaceSelection(wrapKey);\n              }\n            }\n\n            if (e.shiftKey && manager.selectionMode === 'multiple') {\n              manager.extendSelection(nextKey);\n            }\n          }\n\n          break;\n        }\n\n      case 'ArrowUp':\n        {\n          if (delegate.getKeyAbove) {\n            e.preventDefault();\n            let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : delegate.getLastKey();\n\n            if (nextKey != null) {\n              manager.setFocusedKey(nextKey);\n\n              if (manager.selectionMode === 'single' && selectOnFocus) {\n                manager.replaceSelection(nextKey);\n              }\n            } else if (shouldFocusWrap) {\n              let wrapKey = delegate.getLastKey(manager.focusedKey);\n              manager.setFocusedKey(wrapKey);\n\n              if (manager.selectionMode === 'single' && selectOnFocus) {\n                manager.replaceSelection(wrapKey);\n              }\n            }\n\n            if (e.shiftKey && manager.selectionMode === 'multiple') {\n              manager.extendSelection(nextKey);\n            }\n          }\n\n          break;\n        }\n\n      case 'ArrowLeft':\n        {\n          if (delegate.getKeyLeftOf) {\n            e.preventDefault();\n            let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n\n            if (nextKey != null) {\n              manager.setFocusedKey(nextKey);\n\n              if (manager.selectionMode === 'single' && selectOnFocus) {\n                manager.replaceSelection(nextKey);\n              }\n            }\n\n            if (e.shiftKey && manager.selectionMode === 'multiple') {\n              manager.extendSelection(nextKey);\n            }\n          }\n\n          break;\n        }\n\n      case 'ArrowRight':\n        {\n          if (delegate.getKeyRightOf) {\n            e.preventDefault();\n            let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n\n            if (nextKey != null) {\n              manager.setFocusedKey(nextKey);\n\n              if (manager.selectionMode === 'single' && selectOnFocus) {\n                manager.replaceSelection(nextKey);\n              }\n            }\n\n            if (e.shiftKey && manager.selectionMode === 'multiple') {\n              manager.extendSelection(nextKey);\n            }\n          }\n\n          break;\n        }\n\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, $a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n\n          if (manager.selectionMode === 'single' && selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n\n          if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          }\n        }\n\n        break;\n\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, $a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n\n          if (manager.selectionMode === 'single' && selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n\n          if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          }\n        }\n\n        break;\n\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n\n          if (nextKey != null) {\n            manager.setFocusedKey(nextKey);\n\n            if (e.shiftKey && manager.selectionMode === 'multiple') {\n              manager.extendSelection(nextKey);\n            }\n          }\n        }\n\n        break;\n\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n\n          if (nextKey != null) {\n            manager.setFocusedKey(nextKey);\n\n            if (e.shiftKey && manager.selectionMode === 'multiple') {\n              manager.extendSelection(nextKey);\n            }\n          }\n        }\n\n        break;\n\n      case 'a':\n        if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n\n        break;\n\n      case 'Escape':\n        e.preventDefault();\n\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n\n        break;\n\n      case 'Tab':\n        {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {\n              tabbable: true\n            });\n            let next;\n            let last;\n\n            do {\n              last = walker.lastChild();\n\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              next.focus();\n            }\n          }\n\n          break;\n        }\n    }\n  };\n\n  let onFocus = e => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    } // Focus events can bubble through portals. Ignore these events.\n\n\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget;\n\n      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) {\n        var _manager$lastSelected;\n\n        manager.setFocusedKey((_manager$lastSelected = manager.lastSelectedKey) != null ? _manager$lastSelected : delegate.getLastKey());\n      } else {\n        var _manager$firstSelecte;\n\n        manager.setFocusedKey((_manager$firstSelecte = manager.firstSelectedKey) != null ? _manager$firstSelecte : delegate.getFirstKey());\n      }\n    }\n  };\n\n  let onBlur = e => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget)) {\n      manager.setFocused(false);\n    }\n  };\n\n  useEffect(() => {\n    if (autoFocus) {\n      let focusedKey = null; // Check focus strategy to determine which item to focus\n\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      }\n\n      if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      } // If there are any selected keys, make the first one the new focus target\n\n\n      let selectedKeys = manager.selectedKeys;\n\n      if (selectedKeys.size) {\n        focusedKey = selectedKeys.values().next().value;\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey); // If no default focus key is selected, focus the collection itself.\n\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  let handlers = {\n    // We use a capturing listener to ensure that the keyboard events for the collection\n    // override those of the children. For example, ArrowDown in a table should always go\n    // to the cell below, and not open a menu.\n    onKeyDownCapture: onKeyDown,\n    onFocus,\n    onBlur,\n\n    onMouseDown(e) {\n      // Prevent focus going to the collection when clicking on the scrollbar.\n      e.preventDefault();\n    }\n\n  };\n  let {\n    typeSelectProps\n  } = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  } // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n\n\n  let tabIndex;\n\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: _babelRuntimeHelpersEsmExtends({}, handlers, {\n      tabIndex\n    })\n  };\n}\n/**\n * Handles interactions with an item in a selectable collection.\n */\n\nexport function useSelectableItem(options) {\n  let {\n    selectionManager: manager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    isVirtualized,\n    shouldUseVirtualFocus,\n    focus\n  } = options;\n\n  let onSelect = e => manager.select(key, e); // Focus the associated DOM node when this item becomes the focusedKey\n\n\n  let isFocused = key === manager.focusedKey;\n  useEffect(() => {\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) {\n        focus();\n      } else {\n        focusSafely(ref.current);\n      }\n    }\n  }, [ref, isFocused, manager.focusedKey, manager.isFocused, shouldUseVirtualFocus]); // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n\n  let itemProps = {};\n\n  if (!shouldUseVirtualFocus) {\n    itemProps = {\n      tabIndex: isFocused ? 0 : -1,\n\n      onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n\n    };\n  } // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n\n\n  if (shouldSelectOnPressUp) {\n    itemProps.onPressStart = e => {\n      if (e.pointerType === 'keyboard') {\n        onSelect(e);\n      }\n    };\n\n    itemProps.onPressUp = e => {\n      if (e.pointerType !== 'keyboard') {\n        onSelect(e);\n      }\n    };\n  } else {\n    // On touch, it feels strange to select on touch down, so we special case this.\n    itemProps.onPressStart = e => {\n      if (e.pointerType !== 'touch') {\n        onSelect(e);\n      }\n    };\n\n    itemProps.onPress = e => {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n      }\n    };\n  }\n\n  if (!isVirtualized) {\n    itemProps['data-key'] = key;\n  }\n\n  return {\n    itemProps\n  };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport class ListKeyboardDelegate {\n  constructor(collection, disabledKeys, ref, collator) {\n    this.collection = void 0;\n    this.disabledKeys = void 0;\n    this.ref = void 0;\n    this.collator = void 0;\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n\n  getKeyBelow(key) {\n    key = this.collection.getKeyAfter(key);\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyAbove(key) {\n    key = this.collection.getKeyBefore(key);\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getItem(key) {\n    return this.ref.current.querySelector(\"[data-key=\\\"\" + key + \"\\\"]\");\n  }\n\n  getKeyPageAbove(key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n\n    while (item && item.offsetTop > pageY) {\n      key = this.getKeyAbove(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n\n    while (item && item.offsetTop < pageY) {\n      key = this.getKeyBelow(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n\n}\n/**\n * Handles interactions with a selectable list.\n */\n\nexport function useSelectableList(props) {\n  let {\n    selectionManager,\n    collection,\n    disabledKeys,\n    ref,\n    keyboardDelegate,\n    autoFocus,\n    shouldFocusWrap,\n    isVirtualized,\n    disallowEmptySelection,\n    selectOnFocus = false,\n    disallowTypeAhead,\n    shouldUseVirtualFocus\n  } = props; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n\n  let collator = useCollator({\n    usage: 'search',\n    sensitivity: 'base'\n  });\n  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(collection, disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator]); // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n\n  useEffect(() => {\n    if (!isVirtualized && selectionManager.focusedKey) {\n      let element = ref.current.querySelector(\"[data-key=\\\"\" + selectionManager.focusedKey + \"\\\"]\");\n\n      if (element) {\n        $a09ba753e08b703267f2392f7fc8e96$var$scrollIntoView(ref.current, element);\n      }\n    }\n  }, [isVirtualized, ref, selectionManager.focusedKey]);\n  let {\n    collectionProps\n  } = useSelectableCollection({\n    ref,\n    selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus,\n    shouldFocusWrap,\n    disallowEmptySelection,\n    selectOnFocus,\n    disallowTypeAhead,\n    shouldUseVirtualFocus\n  });\n  return {\n    listProps: collectionProps\n  };\n}\n/**\n * Scrolls `scrollView` so that `element` is visible.\n * Similar to `element.scrollIntoView({block: 'nearest'})` (not supported in Edge),\n * but doesn't affect parents above `scrollView`.\n */\n\nfunction $a09ba753e08b703267f2392f7fc8e96$var$scrollIntoView(scrollView, element) {\n  let offsetX = element.offsetLeft - scrollView.offsetLeft;\n  let offsetY = element.offsetTop - scrollView.offsetTop;\n  let width = element.offsetWidth;\n  let height = element.offsetHeight;\n  let x = scrollView.scrollLeft;\n  let y = scrollView.scrollTop;\n  let maxX = x + scrollView.offsetWidth;\n  let maxY = y + scrollView.offsetHeight;\n\n  if (offsetX <= x) {\n    x = offsetX;\n  } else if (offsetX + width > maxX) {\n    x += offsetX + width - maxX;\n  }\n\n  if (offsetY <= y) {\n    y = offsetY;\n  } else if (offsetY + height > maxY) {\n    y += offsetY + height - maxY;\n  }\n\n  scrollView.scrollLeft = x;\n  scrollView.scrollTop = y;\n}","map":{"version":3,"sources":["packages/@react-aria/selection/src/useTypeSelect.ts","packages/@react-aria/selection/src/useSelectableCollection.ts","packages/@react-aria/selection/src/useSelectableItem.ts","packages/@react-aria/selection/src/ListKeyboardDelegate.ts","packages/@react-aria/selection/src/useSelectableList.ts"],"names":["onTypeSelect","state","search","timeout","onKeyDown","e","character","getStringForKey","key","keyboardDelegate","selectionManager","clearTimeout","setTimeout","typeSelectProps","onKeyDownCapture","isMac","window","autoFocus","shouldFocusWrap","disallowEmptySelection","disallowSelectAll","selectOnFocus","disallowTypeAhead","shouldUseVirtualFocus","ref","delegate","nextKey","manager","wrapKey","firstKey","isCtrlKeyPressed","lastKey","walker","getFocusableTreeWalker","tabbable","last","next","document","onFocus","relatedTarget","Node","onBlur","useEffect","focusedKey","selectedKeys","focusSafely","handlers","onMouseDown","mergeProps","tabIndex","collectionProps","focus","onSelect","isFocused","itemProps","collection","disabledKeys","collator","constructor","getKeyBelow","item","getKeyAbove","getFirstKey","getLastKey","getItem","getKeyPageAbove","menu","pageY","Math","getKeyPageBelow","getKeyForSearch","fromKey","substring","useCollator","usage","sensitivity","useMemo","element","scrollIntoView","listProps","offsetX","scrollView","offsetY","width","height","x","y","maxX","maxY"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {HTMLAttributes, Key, KeyboardEvent, useRef} from 'react';\nimport {KeyboardDelegate} from '@react-types/shared';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\ninterface TypeSelectOptions {\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * Called when an item is focused by typing.\n   */\n  onTypeSelect?: (key: Key) => void\n}\n\ninterface TypeSelectAria {\n  /**\n   * Props to be spread on the owner of the options.\n   */\n  typeSelectProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles typeahead interactions with collections.\n */\nexport function useTypeSelect(options: TypeSelectOptions): TypeSelectAria {\n  let {keyboardDelegate, selectionManager, onTypeSelect} = options;\n  let state = useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    let character = getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) {\n      return;\n    }\n\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n\n    state.search += character;\n\n    // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n\n    // If no key found, search from the top.\n    if (key == null) {\n      key = keyboardDelegate.getKeyForSearch(state.search);\n    }\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) {\n        onTypeSelect(key);\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, 500);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction getStringForKey(key: string) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusEvent, HTMLAttributes, KeyboardEvent, RefObject, useEffect} from 'react';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {FocusStrategy, KeyboardDelegate} from '@react-types/shared';\nimport {mergeProps} from '@react-aria/utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useTypeSelect} from './useTypeSelect';\n\nconst isMac =\n  typeof window !== 'undefined' && window.navigator != null\n    ? /^Mac/.test(window.navigator.platform)\n    : false;\n\nfunction isCtrlKeyPressed(e: KeyboardEvent) {\n  if (isMac) {\n    return e.metaKey;\n  }\n\n  return e.ctrlKey;\n}\n\ninterface SelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean\n}\n\ninterface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(options: SelectableCollectionOptions): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = false,\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus\n  } = options;\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Let child element (e.g. menu button) handle the event if the Alt key is pressed.\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (e.altKey || !ref.current.contains(e.target as HTMLElement)) {\n      return;\n    }\n\n    switch (e.key) {\n      case 'ArrowDown': {\n        if (delegate.getKeyBelow) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n            ? delegate.getKeyBelow(manager.focusedKey)\n            : delegate.getFirstKey();\n\n          if (nextKey != null) {\n            manager.setFocusedKey(nextKey);\n            if (manager.selectionMode === 'single' && selectOnFocus) {\n              manager.replaceSelection(nextKey);\n            }\n          } else if (shouldFocusWrap) {\n            let wrapKey = delegate.getFirstKey(manager.focusedKey);\n            manager.setFocusedKey(wrapKey);\n            if (manager.selectionMode === 'single' && selectOnFocus) {\n              manager.replaceSelection(wrapKey);\n            }\n          }\n\n          if (e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(nextKey);\n          }\n        }\n        break;\n      }\n      case 'ArrowUp': {\n        if (delegate.getKeyAbove) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n            ? delegate.getKeyAbove(manager.focusedKey)\n            : delegate.getLastKey();\n\n          if (nextKey != null) {\n            manager.setFocusedKey(nextKey);\n            if (manager.selectionMode === 'single' && selectOnFocus) {\n              manager.replaceSelection(nextKey);\n            }\n          } else if (shouldFocusWrap) {\n            let wrapKey = delegate.getLastKey(manager.focusedKey);\n            manager.setFocusedKey(wrapKey);\n            if (manager.selectionMode === 'single' && selectOnFocus) {\n              manager.replaceSelection(wrapKey);\n            }\n          }\n\n          if (e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(nextKey);\n          }\n        }\n        break;\n      }\n      case 'ArrowLeft': {\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          if (nextKey != null) {\n            manager.setFocusedKey(nextKey);\n            if (manager.selectionMode === 'single' && selectOnFocus) {\n              manager.replaceSelection(nextKey);\n            }\n          }\n          if (e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(nextKey);\n          }\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          if (nextKey != null) {\n            manager.setFocusedKey(nextKey);\n            if (manager.selectionMode === 'single' && selectOnFocus) {\n              manager.replaceSelection(nextKey);\n            }\n          }\n          if (e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(nextKey);\n          }\n        }\n        break;\n      }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if (manager.selectionMode === 'single' && selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if (manager.selectionMode === 'single' && selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          if (nextKey != null) {\n            manager.setFocusedKey(nextKey);\n            if (e.shiftKey && manager.selectionMode === 'multiple') {\n              manager.extendSelection(nextKey);\n            }\n          }\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          if (nextKey != null) {\n            manager.setFocusedKey(nextKey);\n            if (e.shiftKey && manager.selectionMode === 'multiple') {\n              manager.extendSelection(nextKey);\n            }\n          }\n        }\n        break;\n      case 'a':\n        if (isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab': {\n        // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n        // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n        // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n        // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n        // in the collection, so that the browser default behavior will apply starting from that element\n        // rather than the currently focused one.\n        if (e.shiftKey) {\n          ref.current.focus();\n        } else {\n          let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n          let next: HTMLElement;\n          let last: HTMLElement;\n          do {\n            last = walker.lastChild() as HTMLElement;\n            if (last) {\n              next = last;\n            }\n          } while (last);\n\n          if (next && !next.contains(document.activeElement)) {\n            next.focus();\n          }\n        }\n        break;\n      }\n    }\n  };\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      if (relatedTarget && (e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)) {\n        manager.setFocusedKey(manager.lastSelectedKey ?? delegate.getLastKey());\n      } else {\n        manager.setFocusedKey(manager.firstSelectedKey ?? delegate.getFirstKey());\n      }\n    }\n  };\n\n  let onBlur = (e) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  useEffect(() => {\n    if (autoFocus) {\n      let focusedKey = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      } if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        focusedKey = selectedKeys.values().next().value;\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  let handlers = {\n    // We use a capturing listener to ensure that the keyboard events for the collection\n    // override those of the children. For example, ArrowDown in a table should always go\n    // to the cell below, and not open a menu.\n    onKeyDownCapture: onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e) {\n      // Prevent focus going to the collection when clicking on the scrollbar.\n      e.preventDefault();\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex: number;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {focusSafely} from '@react-aria/focus';\nimport {HTMLAttributes, Key, RefObject, useEffect} from 'react';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {PressEvent} from '@react-types/shared';\nimport {PressProps} from '@react-aria/interactions';\n\ninterface SelectableItemOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A unique key for the item.\n   */\n  key: Key,\n  /**\n   * Ref to the item.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * By default, selection occurs on pointer down. This can be strange if selecting an\n   * item causes the UI to disappear immediately (e.g. menus).\n   */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Function to focus the item.\n   */\n  focus?: () => void,\n  /**\n   * Whether the option should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean\n}\n\ninterface SelectableItemAria {\n  /**\n   * Props to be spread on the item root node.\n   */\n  itemProps: HTMLAttributes<HTMLElement> & PressProps\n}\n\n/**\n * Handles interactions with an item in a selectable collection.\n */\nexport function useSelectableItem(options: SelectableItemOptions): SelectableItemAria {\n  let {\n    selectionManager: manager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    isVirtualized,\n    shouldUseVirtualFocus,\n    focus\n  } = options;\n\n  let onSelect = (e: PressEvent | PointerEvent) => manager.select(key, e);\n\n  // Focus the associated DOM node when this item becomes the focusedKey\n  let isFocused = key === manager.focusedKey;\n  useEffect(() => {\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) {\n        focus();\n      } else {\n        focusSafely(ref.current);\n      }\n    }\n  }, [ref, isFocused, manager.focusedKey, manager.isFocused, shouldUseVirtualFocus]);\n\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps: SelectableItemAria['itemProps'] = {};\n  if (!shouldUseVirtualFocus) {\n    itemProps = {\n      tabIndex: isFocused ? 0 : -1,\n      onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  }\n\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  if (shouldSelectOnPressUp) {\n    itemProps.onPressStart = (e) => {\n      if (e.pointerType === 'keyboard') {\n        onSelect(e);\n      }\n    };\n\n    itemProps.onPressUp = (e) => {\n      if (e.pointerType !== 'keyboard') {\n        onSelect(e);\n      }\n    };\n  } else {\n    // On touch, it feels strange to select on touch down, so we special case this.\n    itemProps.onPressStart = (e) => {\n      if (e.pointerType !== 'touch') {\n        onSelect(e);\n      }\n    };\n\n    itemProps.onPress = (e) => {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n      }\n    };\n  }\n\n  if (!isVirtualized) {\n    itemProps['data-key'] = key;\n  }\n\n  return {\n    itemProps\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, KeyboardDelegate, Node} from '@react-types/shared';\nimport {Key, RefObject} from 'react';\n\nexport class ListKeyboardDelegate<T> implements KeyboardDelegate {\n  private collection: Collection<Node<T>>;\n  private disabledKeys: Set<Key>;\n  private ref: RefObject<HTMLElement>;\n  private collator: Intl.Collator;\n\n  constructor(collection: Collection<Node<T>>, disabledKeys: Set<Key>, ref: RefObject<HTMLElement>, collator?: Intl.Collator) {\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n\n  getKeyBelow(key: Key) {\n    key = this.collection.getKeyAfter(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    key = this.collection.getKeyBefore(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  private getItem(key: Key): HTMLElement {\n    return this.ref.current.querySelector(`[data-key=\"${key}\"]`);\n  }\n\n  getKeyPageAbove(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n\n    while (item && item.offsetTop > pageY) {\n      key = this.getKeyAbove(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n\n    while (item && item.offsetTop < pageY) {\n      key = this.getKeyBelow(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, FocusStrategy, KeyboardDelegate, Node} from '@react-types/shared';\nimport {HTMLAttributes, Key, RefObject, useEffect, useMemo} from 'react';\nimport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useCollator} from '@react-aria/i18n';\nimport {useSelectableCollection} from './useSelectableCollection';\n\ninterface SelectableListOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * State of the collection.\n   */\n  collection: Collection<Node<unknown>>,\n  /**\n   * The item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with.\n   */\n  disabledKeys: Set<Key>,\n  /**\n   * A ref to the item.\n   */\n  ref?: RefObject<HTMLElement>,\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate?: KeyboardDelegate,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean\n}\n\ninterface SelectableListAria {\n  /**\n   * Props for the option element.\n   */\n  listProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with a selectable list.\n */\nexport function useSelectableList(props: SelectableListOptions): SelectableListAria {\n  let {\n    selectionManager,\n    collection,\n    disabledKeys,\n    ref,\n    keyboardDelegate,\n    autoFocus,\n    shouldFocusWrap,\n    isVirtualized,\n    disallowEmptySelection,\n    selectOnFocus = false,\n    disallowTypeAhead,\n    shouldUseVirtualFocus\n  } = props;\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = useCollator({usage: 'search', sensitivity: 'base'});\n  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(collection, disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator]);\n\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  useEffect(() => {\n    if (!isVirtualized && selectionManager.focusedKey) {\n      let element = ref.current.querySelector(`[data-key=\"${selectionManager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        scrollIntoView(ref.current, element);\n      }\n    }\n  }, [isVirtualized, ref, selectionManager.focusedKey]);\n\n  let {collectionProps} = useSelectableCollection({\n    ref,\n    selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus,\n    shouldFocusWrap,\n    disallowEmptySelection,\n    selectOnFocus,\n    disallowTypeAhead,\n    shouldUseVirtualFocus\n  });\n\n  return {\n    listProps: collectionProps\n  };\n}\n\n/**\n * Scrolls `scrollView` so that `element` is visible.\n * Similar to `element.scrollIntoView({block: 'nearest'})` (not supported in Edge),\n * but doesn't affect parents above `scrollView`.\n */\nfunction scrollIntoView(scrollView: HTMLElement, element: HTMLElement) {\n  let offsetX = element.offsetLeft - scrollView.offsetLeft;\n  let offsetY = element.offsetTop - scrollView.offsetTop;\n  let width = element.offsetWidth;\n  let height = element.offsetHeight;\n  let x = scrollView.scrollLeft;\n  let y = scrollView.scrollTop;\n  let maxX = x + scrollView.offsetWidth;\n  let maxY = y + scrollView.offsetHeight;\n\n  if (offsetX <= x) {\n    x = offsetX;\n  } else if (offsetX + width > maxX) {\n    x += offsetX + width - maxX;\n  }\n  if (offsetY <= y) {\n    y = offsetY;\n  } else if (offsetY + height > maxY) {\n    y += offsetY + height - maxY;\n  }\n\n  scrollView.scrollLeft = x;\n  scrollView.scrollTop = y;\n}\n"]},"metadata":{},"sourceType":"module"}