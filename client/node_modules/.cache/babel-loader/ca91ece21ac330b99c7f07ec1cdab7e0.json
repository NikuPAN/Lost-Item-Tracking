{"ast":null,"code":"import _babelRuntimeHelpersEsmExtends from \"@babel/runtime/helpers/esm/extends\";\nimport _react, { useMemo, useRef } from \"react\";\n\nfunction $e92117d6e5313ef8e7c10fac1de193ce$var$Item(props) {\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\n$e92117d6e5313ef8e7c10fac1de193ce$var$Item.getCollectionNode = function* getCollectionNode(props) {\n  let {\n    childItems,\n    title,\n    children\n  } = props;\n  let rendered = props.title || props.children;\n  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'] || '';\n\n  if (!textValue) {\n    console.warn('<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.');\n  }\n\n  yield {\n    type: 'item',\n    props: props,\n    rendered,\n    textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: $e92117d6e5313ef8e7c10fac1de193ce$var$hasChildItems(props),\n\n    *childNodes() {\n      if (childItems) {\n        for (let child of childItems) {\n          yield {\n            type: 'item',\n            value: child\n          };\n        }\n      } else if (title) {\n        let items = [];\n\n        _react.Children.forEach(children, child => {\n          items.push({\n            type: 'item',\n            element: child\n          });\n        });\n\n        yield* items;\n      }\n    }\n\n  };\n};\n\nfunction $e92117d6e5313ef8e7c10fac1de193ce$var$hasChildItems(props) {\n  if (props.hasChildItems != null) {\n    return props.hasChildItems;\n  }\n\n  if (props.childItems) {\n    return true;\n  }\n\n  if (props.title && _react.Children.count(props.children) > 0) {\n    return true;\n  }\n\n  return false;\n} // We don't want getCollectionNode to show up in the type definition\n\n\nexport let Item = $e92117d6e5313ef8e7c10fac1de193ce$var$Item;\n\nfunction $b2e76f05d3356a2e1df6ac80570fcd9$var$Section(props) {\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\n$b2e76f05d3356a2e1df6ac80570fcd9$var$Section.getCollectionNode = function* getCollectionNode(props) {\n  let {\n    children,\n    title,\n    items\n  } = props;\n  yield {\n    type: 'section',\n    hasChildNodes: true,\n    rendered: title,\n    'aria-label': props['aria-label'],\n\n    *childNodes() {\n      if (typeof children === 'function') {\n        if (!items) {\n          throw new Error('props.children was a function but props.items is missing');\n        }\n\n        for (let item of items) {\n          yield {\n            type: 'item',\n            value: item,\n            renderer: children\n          };\n        }\n      } else {\n        let items = [];\n\n        _react.Children.forEach(children, child => {\n          items.push({\n            type: 'item',\n            element: child\n          });\n        });\n\n        yield* items;\n      }\n    }\n\n  };\n}; // We don't want getCollectionNode to show up in the type definition\n\n\nexport let Section = $b2e76f05d3356a2e1df6ac80570fcd9$var$Section;\n\nclass $f8429209754fda4b9142d514065f4$export$CollectionBuilder {\n  constructor() {\n    this.context = void 0;\n    this.cache = new WeakMap();\n  }\n\n  build(props, context) {\n    this.context = context;\n    return $f8429209754fda4b9142d514065f4$var$iterable(() => this.iterateCollection(props));\n  }\n\n  *iterateCollection(props) {\n    let {\n      children,\n      items\n    } = props;\n\n    if (typeof children === 'function') {\n      if (!items) {\n        throw new Error('props.children was a function but props.items is missing');\n      }\n\n      for (let item of props.items) {\n        yield* this.getFullNode({\n          value: item\n        }, {\n          renderer: children\n        });\n      }\n    } else {\n      let items = [];\n\n      _react.Children.forEach(children, child => {\n        items.push(child);\n      });\n\n      let index = 0;\n\n      for (let item of items) {\n        let nodes = this.getFullNode({\n          element: item,\n          index: index\n        }, {});\n\n        for (let node of nodes) {\n          index++;\n          yield node;\n        }\n      }\n    }\n  }\n\n  getKey(item, partialNode, state, parentKey) {\n    if (item.key != null) {\n      return item.key;\n    }\n\n    if (partialNode.type === 'cell' && partialNode.key != null) {\n      return \"\" + parentKey + partialNode.key;\n    }\n\n    let v = partialNode.value;\n\n    if (v != null) {\n      var _v$key;\n\n      let key = (_v$key = v.key) != null ? _v$key : v.id;\n\n      if (key == null) {\n        throw new Error('No key found for item');\n      }\n\n      return key;\n    }\n\n    return parentKey ? parentKey + \".\" + partialNode.index : \"$.\" + partialNode.index;\n  }\n\n  getChildState(state, partialNode) {\n    return {\n      renderer: partialNode.renderer || state.renderer\n    };\n  }\n\n  *getFullNode(partialNode, state, parentKey, parentNode) {\n    // If there's a value instead of an element on the node, and a parent renderer function is available,\n    // use it to render an element for the value.\n    let element = partialNode.element;\n\n    if (!element && partialNode.value && state && state.renderer) {\n      let cached = this.cache.get(partialNode.value);\n\n      if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {\n        cached.index = partialNode.index;\n        yield cached;\n        return;\n      }\n\n      element = state.renderer(partialNode.value);\n    } // If there's an element with a getCollectionNode function on its type, then it's a supported component.\n    // Call this function to get a partial node, and recursively build a full node from there.\n\n\n    if (_react.isValidElement(element)) {\n      let type = element.type;\n\n      if (typeof type !== 'function' || typeof type.getCollectionNode !== 'function') {\n        let name = typeof element.type === 'function' ? element.type.name : element.type;\n        throw new Error(\"Unknown element <\" + name + \"> in collection.\");\n      }\n\n      let childNodes = type.getCollectionNode(element.props, this.context);\n      let index = partialNode.index;\n      let result = childNodes.next();\n\n      while (!result.done && result.value) {\n        let childNode = result.value;\n        partialNode.index = index;\n        let nodes = this.getFullNode(_babelRuntimeHelpersEsmExtends({}, childNode, {\n          key: childNode.element ? null : this.getKey(element, partialNode, state, parentKey),\n          index,\n          wrapper: $f8429209754fda4b9142d514065f4$var$compose(partialNode.wrapper, childNode.wrapper)\n        }), this.getChildState(state, childNode), parentKey ? \"\" + parentKey + element.key : element.key, parentNode);\n        let children = [...nodes];\n\n        for (let node of children) {\n          // Cache the node based on its value\n          node.value = childNode.value || partialNode.value;\n\n          if (node.value) {\n            this.cache.set(node.value, node);\n          } // The partial node may have specified a type for the child in order to specify a constraint.\n          // Verify that the full node that was built recursively matches this type.\n\n\n          if (partialNode.type && node.type !== partialNode.type) {\n            throw new Error(\"Unsupported type <\" + $f8429209754fda4b9142d514065f4$var$capitalize(node.type) + \"> in <\" + $f8429209754fda4b9142d514065f4$var$capitalize(parentNode.type) + \">. Only <\" + $f8429209754fda4b9142d514065f4$var$capitalize(partialNode.type) + \"> is supported.\");\n          }\n\n          index++;\n          yield node;\n        }\n\n        result = childNodes.next(children);\n      }\n\n      return;\n    } // Ignore invalid elements\n\n\n    if (partialNode.key == null) {\n      return;\n    } // Create full node\n\n\n    let builder = this;\n    let node = {\n      type: partialNode.type,\n      props: partialNode.props,\n      key: partialNode.key,\n      parentKey: parentNode ? parentNode.key : null,\n      value: partialNode.value,\n      level: parentNode ? parentNode.level + 1 : 0,\n      index: partialNode.index,\n      rendered: partialNode.rendered,\n      textValue: partialNode.textValue,\n      'aria-label': partialNode['aria-label'],\n      wrapper: partialNode.wrapper,\n      shouldInvalidate: partialNode.shouldInvalidate,\n      hasChildNodes: partialNode.hasChildNodes,\n      childNodes: $f8429209754fda4b9142d514065f4$var$iterable(function* () {\n        if (!partialNode.hasChildNodes) {\n          return;\n        }\n\n        let index = 0;\n\n        for (let child of partialNode.childNodes()) {\n          // Ensure child keys are globally unique by prepending the parent node's key\n          if (child.key != null) {\n            child.key = \"\" + node.key + child.key;\n          }\n\n          child.index = index;\n          let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);\n\n          for (let node of nodes) {\n            index++;\n            yield node;\n          }\n        }\n      })\n    };\n    yield node;\n  }\n\n} // Wraps an iterator function as an iterable object, and caches the results.\n\n\nfunction $f8429209754fda4b9142d514065f4$var$iterable(iterator) {\n  let cache = [];\n  let iterable = null;\n  return {\n    *[Symbol.iterator]() {\n      for (let item of cache) {\n        yield item;\n      }\n\n      if (!iterable) {\n        iterable = iterator();\n      }\n\n      for (let item of iterable) {\n        cache.push(item);\n        yield item;\n      }\n    }\n\n  };\n}\n\nfunction $f8429209754fda4b9142d514065f4$var$compose(outer, inner) {\n  if (outer && inner) {\n    return element => outer(inner(element));\n  }\n\n  if (outer) {\n    return outer;\n  }\n\n  if (inner) {\n    return inner;\n  }\n}\n\nfunction $f8429209754fda4b9142d514065f4$var$capitalize(str) {\n  return str[0].toUpperCase() + str.slice(1);\n}\n\nexport function useCollection(props, factory, context, invalidators) {\n  if (invalidators === void 0) {\n    invalidators = [];\n  }\n\n  let builder = useMemo(() => new $f8429209754fda4b9142d514065f4$export$CollectionBuilder(), []);\n  let prev = useRef(null);\n  return useMemo(() => {\n    let nodes = builder.build(props, context);\n    prev.current = factory(nodes, prev.current);\n    return prev.current; // Don't invalidate when any prop changes, just the two we care about.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [builder, props.children, props.items, context, ...invalidators]);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $c10674539d06c96e1a2fbb6a54340$var$cache = new WeakMap();\nexport function getItemCount(collection) {\n  let count = $c10674539d06c96e1a2fbb6a54340$var$cache.get(collection);\n\n  if (count != null) {\n    return count;\n  }\n\n  count = 0;\n\n  for (let item of collection) {\n    if (item.type === 'section') {\n      count += getItemCount(item.childNodes);\n    } else {\n      count++;\n    }\n  }\n\n  $c10674539d06c96e1a2fbb6a54340$var$cache.set(collection, count);\n  return count;\n}","map":{"version":3,"sources":["packages/@react-stately/collections/src/Item.ts","packages/@react-stately/collections/src/Section.ts","packages/@react-stately/collections/src/CollectionBuilder.ts","packages/@react-stately/collections/src/useCollection.ts","packages/@react-stately/collections/src/getItemCount.ts"],"names":["Item","children","rendered","props","textValue","console","type","hasChildNodes","hasChildItems","value","child","items","React","element","_Item","Section","renderer","_Section","build","iterable","item","index","nodes","getKey","partialNode","v","key","parentKey","getChildState","state","cached","name","childNodes","result","childNode","wrapper","compose","node","capitalize","parentNode","builder","level","shouldInvalidate","cache","Symbol","iterator","outer","inner","str","invalidators","useMemo","prev","useRef","factory","count","getItemCount"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ItemElement, ItemProps} from '@react-types/shared';\nimport {PartialNode} from './types';\nimport React, {ReactElement} from 'react';\n\nfunction Item<T>(props: ItemProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nItem.getCollectionNode = function* getCollectionNode<T>(props: ItemProps<T>): Generator<PartialNode<T>> {\n  let {childItems, title, children} = props;\n\n  let rendered = props.title || props.children;\n  let textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'] || '';\n  if (!textValue) {\n    console.warn('<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.');\n  }\n\n  yield {\n    type: 'item',\n    props: props,\n    rendered,\n    textValue,\n    'aria-label': props['aria-label'],\n    hasChildNodes: hasChildItems(props),\n    *childNodes() {\n      if (childItems) {\n        for (let child of childItems) {\n          yield {\n            type: 'item',\n            value: child\n          };\n        }\n      } else if (title) {\n        let items: PartialNode<T>[] = [];\n        React.Children.forEach(children, child => {\n          items.push({\n            type: 'item',\n            element: child as ItemElement<T>\n          });\n        });\n\n        yield* items;\n      }\n    }\n  };\n};\n\nfunction hasChildItems<T>(props: ItemProps<T>) {\n  if (props.hasChildItems != null) {\n    return props.hasChildItems;\n  }\n\n  if (props.childItems) {\n    return true;\n  }\n\n  if (props.title && React.Children.count(props.children) > 0) {\n    return true;\n  }\n\n  return false;\n}\n\n// We don't want getCollectionNode to show up in the type definition\nlet _Item = Item as <T>(props: ItemProps<T>) => JSX.Element;\nexport {_Item as Item};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {PartialNode} from './types';\nimport React, {ReactElement} from 'react';\nimport {SectionProps} from '@react-types/shared';\n\nfunction Section<T>(props: SectionProps<T>): ReactElement { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null;\n}\n\nSection.getCollectionNode = function* getCollectionNode<T>(props: SectionProps<T>): Generator<PartialNode<T>> {\n  let {children, title, items} = props;\n  yield {\n    type: 'section',\n    hasChildNodes: true,\n    rendered: title,\n    'aria-label': props['aria-label'],\n    *childNodes() {\n      if (typeof children === 'function') {\n        if (!items) {\n          throw new Error('props.children was a function but props.items is missing');\n        }\n    \n        for (let item of items) {\n          yield {\n            type: 'item',\n            value: item,\n            renderer: children\n          };\n        }\n      } else {\n        let items: PartialNode<T>[] = [];\n        React.Children.forEach(children, child => {\n          items.push({\n            type: 'item',\n            element: child\n          });\n        });\n\n        yield* items;\n      }\n    }\n  };\n};\n\n// We don't want getCollectionNode to show up in the type definition\nlet _Section = Section as <T>(props: SectionProps<T>) => JSX.Element;\nexport {_Section as Section};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBase, CollectionElement, Node} from '@react-types/shared';\nimport {PartialNode} from './types';\nimport React, {Key, ReactElement} from 'react';\n\ninterface CollectionBuilderState {\n  renderer?: (value: any) => ReactElement\n}\n\nexport class CollectionBuilder<T extends object> {\n  private context?: unknown;\n  private cache: WeakMap<T, Node<T>> = new WeakMap();\n\n  build(props: CollectionBase<T>, context?: unknown) {\n    this.context = context;\n    return iterable(() => this.iterateCollection(props));\n  }\n\n  private *iterateCollection(props: CollectionBase<T>) {\n    let {children, items} = props;\n\n    if (typeof children === 'function') {\n      if (!items) {\n        throw new Error('props.children was a function but props.items is missing');\n      }\n\n      for (let item of props.items) {\n        yield* this.getFullNode({\n          value: item\n        }, {renderer: children});\n      }\n    } else {\n      let items: CollectionElement<T>[] = [];\n      React.Children.forEach(children, child => {\n        items.push(child);\n      });\n\n      let index = 0;\n      for (let item of items) {\n        let nodes = this.getFullNode({\n          element: item,\n          index: index\n        }, {});\n\n        for (let node of nodes) {\n          index++;\n          yield node;\n        }\n      }\n    }\n  }\n\n  private getKey(item: CollectionElement<T>, partialNode: PartialNode<T>, state: CollectionBuilderState, parentKey?: Key): Key {\n    if (item.key != null) {\n      return item.key;\n    }\n\n    if (partialNode.type === 'cell' && partialNode.key != null) {\n      return `${parentKey}${partialNode.key}`;\n    }\n\n    let v = partialNode.value as any;\n    if (v != null) {\n      let key = v.key ?? v.id;\n      if (key == null) {\n        throw new Error('No key found for item');\n      }\n\n      return key;\n    }\n\n    return parentKey ? `${parentKey}.${partialNode.index}` : `$.${partialNode.index}`;\n  }\n\n  private getChildState(state: CollectionBuilderState, partialNode: PartialNode<T>) {\n    return {\n      renderer: partialNode.renderer || state.renderer\n    };\n  }\n\n  private *getFullNode(partialNode: PartialNode<T>, state: CollectionBuilderState, parentKey?: Key, parentNode?: Node<T>): Generator<Node<T>> {\n    // If there's a value instead of an element on the node, and a parent renderer function is available,\n    // use it to render an element for the value.\n    let element = partialNode.element;\n    if (!element && partialNode.value && state && state.renderer) {\n      let cached = this.cache.get(partialNode.value);\n      if (cached && (!cached.shouldInvalidate || !cached.shouldInvalidate(this.context))) {\n        cached.index = partialNode.index;\n        yield cached;\n        return;\n      }\n\n      element = state.renderer(partialNode.value);\n    }\n\n    // If there's an element with a getCollectionNode function on its type, then it's a supported component.\n    // Call this function to get a partial node, and recursively build a full node from there.\n    if (React.isValidElement(element)) {\n      let type = element.type as any;\n      if (typeof type !== 'function' || typeof type.getCollectionNode !== 'function') {\n        let name = typeof element.type === 'function' ? element.type.name : element.type;\n        throw new Error(`Unknown element <${name}> in collection.`);\n      }\n\n      let childNodes = type.getCollectionNode(element.props, this.context) as Generator<PartialNode<T>, void, Node<T>[]>;\n      let index = partialNode.index;\n      let result = childNodes.next();\n      while (!result.done && result.value) {\n        let childNode = result.value;\n\n        partialNode.index = index;\n        let nodes = this.getFullNode({\n          ...childNode,\n          key: childNode.element ? null : this.getKey(element as CollectionElement<T>, partialNode, state, parentKey),\n          index,\n          wrapper: compose(partialNode.wrapper, childNode.wrapper)\n        }, this.getChildState(state, childNode), parentKey ? `${parentKey}${element.key}` : element.key, parentNode);\n\n        let children = [...nodes];\n        for (let node of children) {\n          // Cache the node based on its value\n          node.value = childNode.value || partialNode.value;\n          if (node.value) {\n            this.cache.set(node.value, node);\n          }\n\n          // The partial node may have specified a type for the child in order to specify a constraint.\n          // Verify that the full node that was built recursively matches this type.\n          if (partialNode.type && node.type !== partialNode.type) {\n            throw new Error(`Unsupported type <${capitalize(node.type)}> in <${capitalize(parentNode.type)}>. Only <${capitalize(partialNode.type)}> is supported.`);\n          }\n\n          index++;\n          yield node;\n        }\n\n        result = childNodes.next(children);\n      }\n\n      return;\n    }\n\n    // Ignore invalid elements\n    if (partialNode.key == null) {\n      return;\n    }\n\n    // Create full node\n    let builder = this;\n    let node: Node<T> = {\n      type: partialNode.type,\n      props: partialNode.props,\n      key: partialNode.key,\n      parentKey: parentNode ? parentNode.key : null,\n      value: partialNode.value,\n      level: parentNode ? parentNode.level + 1 : 0,\n      index: partialNode.index,\n      rendered: partialNode.rendered,\n      textValue: partialNode.textValue,\n      'aria-label': partialNode['aria-label'],\n      wrapper: partialNode.wrapper,\n      shouldInvalidate: partialNode.shouldInvalidate,\n      hasChildNodes: partialNode.hasChildNodes,\n      childNodes: iterable(function *() {\n        if (!partialNode.hasChildNodes) {\n          return;\n        }\n\n        let index = 0;\n        for (let child of partialNode.childNodes()) {\n          // Ensure child keys are globally unique by prepending the parent node's key\n          if (child.key != null) {\n            child.key = `${node.key}${child.key}`;\n          }\n\n          child.index = index;\n          let nodes = builder.getFullNode(child, builder.getChildState(state, child), node.key, node);\n          for (let node of nodes) {\n            index++;\n            yield node;\n          }\n        }\n      })\n    };\n\n    yield node;\n  }\n}\n\n// Wraps an iterator function as an iterable object, and caches the results.\nfunction iterable<T>(iterator: () => IterableIterator<Node<T>>): Iterable<Node<T>> {\n  let cache = [];\n  let iterable = null;\n  return {\n    *[Symbol.iterator]() {\n      for (let item of cache) {\n        yield item;\n      }\n\n      if (!iterable) {\n        iterable = iterator();\n      }\n\n      for (let item of iterable) {\n        cache.push(item);\n        yield item;\n      }\n    }\n  };\n}\n\ntype Wrapper = (element: ReactElement) => ReactElement;\nfunction compose(outer: Wrapper | void, inner: Wrapper | void): Wrapper {\n  if (outer && inner) {\n    return (element) => outer(inner(element));\n  }\n\n  if (outer) {\n    return outer;\n  }\n\n  if (inner) {\n    return inner;\n  }\n}\n\nfunction capitalize(str: string) {\n  return str[0].toUpperCase() + str.slice(1);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, CollectionBase, Node} from '@react-types/shared';\nimport {CollectionBuilder} from './CollectionBuilder';\nimport {useMemo, useRef} from 'react';\n\ntype CollectionFactory<T, C extends Collection<Node<T>>> = (node: Iterable<Node<T>>, prev: C | null) => C;\n\nexport function useCollection<T extends object, C extends Collection<Node<T>> = Collection<Node<T>>>(props: CollectionBase<T>, factory: CollectionFactory<T, C>, context?: unknown, invalidators: Array<any> = []): C {\n  let builder = useMemo(() => new CollectionBuilder<T>(), []);\n\n  let prev = useRef<C>(null);\n  return useMemo(() => {\n    let nodes = builder.build(props, context);\n    prev.current = factory(nodes, prev.current);\n    return prev.current;\n  // Don't invalidate when any prop changes, just the two we care about.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [builder, props.children, props.items, context, ...invalidators]);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Node} from '@react-types/shared';\n\nconst cache = new WeakMap<Iterable<unknown>, number>();\n\nexport function getItemCount<T>(collection: Iterable<Node<T>>): number {\n  let count = cache.get(collection);\n  if (count != null) {\n    return count;\n  }\n\n  count = 0;\n  for (let item of collection) {\n    if (item.type === 'section') {\n      count += getItemCount(item.childNodes);\n    } else {\n      count++;\n    }\n  }\n\n  cache.set(collection, count);\n  return count;\n}\n"]},"metadata":{},"sourceType":"module"}