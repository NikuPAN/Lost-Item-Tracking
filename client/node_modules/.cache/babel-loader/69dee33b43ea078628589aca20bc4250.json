{"ast":null,"code":"import { useState, useEffect, useReducer, useMemo } from \"react\";\nimport _babelRuntimeHelpersEsmExtends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * Manages state for an immutable list data structure, and provides convenience methods to\n * update the data over time.\n */\n\nexport function useListData(options) {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = item => item.id || item.key\n  } = options;\n  let [state, setState] = useState({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || [])\n  });\n  return _babelRuntimeHelpersEsmExtends({}, state, $b778f1542e2cf1e9d9f1c7276a173aec$export$createListActions({\n    getKey\n  }, setState), {\n    getItem(key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n\n  });\n}\n\nfunction $b778f1542e2cf1e9d9f1c7276a173aec$var$insert(state, index) {\n  for (var _len = arguments.length, values = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    values[_key - 2] = arguments[_key];\n  }\n\n  return _babelRuntimeHelpersEsmExtends({}, state, {\n    items: [...state.items.slice(0, index), ...values, ...state.items.slice(index)]\n  });\n}\n\nfunction $b778f1542e2cf1e9d9f1c7276a173aec$export$createListActions(opts, dispatch) {\n  let {\n    getKey\n  } = opts;\n  return {\n    setSelectedKeys(selectedKeys) {\n      dispatch(state => _babelRuntimeHelpersEsmExtends({}, state, {\n        selectedKeys\n      }));\n    },\n\n    insert(index) {\n      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        values[_key2 - 1] = arguments[_key2];\n      }\n\n      dispatch(state => $b778f1542e2cf1e9d9f1c7276a173aec$var$insert(state, index, ...values));\n    },\n\n    insertBefore(key) {\n      for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        values[_key3 - 1] = arguments[_key3];\n      }\n\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n\n        if (index === -1) {\n          return;\n        }\n\n        return $b778f1542e2cf1e9d9f1c7276a173aec$var$insert(state, index, ...values);\n      });\n    },\n\n    insertAfter(key) {\n      for (var _len4 = arguments.length, values = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        values[_key4 - 1] = arguments[_key4];\n      }\n\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n\n        if (index === -1) {\n          return;\n        }\n\n        return $b778f1542e2cf1e9d9f1c7276a173aec$var$insert(state, index + 1, ...values);\n      });\n    },\n\n    prepend() {\n      for (var _len5 = arguments.length, values = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        values[_key5] = arguments[_key5];\n      }\n\n      dispatch(state => $b778f1542e2cf1e9d9f1c7276a173aec$var$insert(state, 0, ...values));\n    },\n\n    append() {\n      for (var _len6 = arguments.length, values = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        values[_key6] = arguments[_key6];\n      }\n\n      dispatch(state => $b778f1542e2cf1e9d9f1c7276a173aec$var$insert(state, state.items.length, ...values));\n    },\n\n    remove() {\n      for (var _len7 = arguments.length, keys = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        keys[_key7] = arguments[_key7];\n      }\n\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n        let selection = new Set(state.selectedKeys);\n\n        for (let key of keys) {\n          selection.delete(key);\n        }\n\n        return _babelRuntimeHelpersEsmExtends({}, state, {\n          items,\n          selectedKeys: selection\n        });\n      });\n    },\n\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') {\n          return _babelRuntimeHelpersEsmExtends({}, state, {\n            items: [],\n            selectedKeys: new Set()\n          });\n        }\n\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return _babelRuntimeHelpersEsmExtends({}, state, {\n          items,\n          selectedKeys: new Set()\n        });\n      });\n    },\n\n    move(key, toIndex) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n\n        if (index === -1) {\n          return state;\n        }\n\n        let copy = state.items.slice();\n        let [item] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item);\n        return _babelRuntimeHelpersEsmExtends({}, state, {\n          items: copy\n        });\n      });\n    },\n\n    update(key, newValue) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n\n        if (index === -1) {\n          return state;\n        }\n\n        return _babelRuntimeHelpersEsmExtends({}, state, {\n          items: [...state.items.slice(0, index), newValue, ...state.items.slice(index + 1)]\n        });\n      });\n    }\n\n  };\n}\n\nfunction $ebfe0ef2c160f1de1367205924a0b01e$var$reducer(data, action) {\n  var _action$sortDescripto, _action$selectedKeys, _action$sortDescripto2, _action$selectedKeys2, _action$sortDescripto3;\n\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n          return _babelRuntimeHelpersEsmExtends({}, data, {\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: (_action$sortDescripto = action.sortDescriptor) != null ? _action$sortDescripto : data.sortDescriptor,\n            abortController: action.abortController\n          });\n\n        case 'update':\n          return _babelRuntimeHelpersEsmExtends({}, data, action.updater(data));\n\n        case 'success':\n        case 'error':\n          return data;\n\n        default:\n          throw new Error(\"Invalid action \\\"\" + action.type + \"\\\" in state \\\"\" + data.state + \"\\\"\");\n      }\n\n    case 'loading':\n    case 'sorting':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return _babelRuntimeHelpersEsmExtends({}, data, {\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: new Set((_action$selectedKeys = action.selectedKeys) != null ? _action$selectedKeys : data.selectedKeys),\n            sortDescriptor: (_action$sortDescripto2 = action.sortDescriptor) != null ? _action$sortDescripto2 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          });\n\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return _babelRuntimeHelpersEsmExtends({}, data, {\n            state: 'error',\n            error: action.error,\n            abortController: null\n          });\n\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          return _babelRuntimeHelpersEsmExtends({}, data, {\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          });\n\n        default:\n          throw new Error(\"Invalid action \\\"\" + action.type + \"\\\" in state \\\"\" + data.state + \"\\\"\");\n      }\n\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          // Append the new items\n          return _babelRuntimeHelpersEsmExtends({}, data, {\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys: new Set([...data.selectedKeys, ...((_action$selectedKeys2 = action.selectedKeys) != null ? _action$selectedKeys2 : [])]),\n            sortDescriptor: (_action$sortDescripto3 = action.sortDescriptor) != null ? _action$sortDescripto3 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          });\n\n        case 'error':\n          return _babelRuntimeHelpersEsmExtends({}, data, {\n            state: 'error',\n            error: action.error\n          });\n\n        case 'loading':\n        case 'sorting':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          return _babelRuntimeHelpersEsmExtends({}, data, {\n            state: 'loading',\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          });\n\n        default:\n          throw new Error(\"Invalid action \\\"\" + action.type + \"\\\" in state \\\"\" + data.state + \"\\\"\");\n      }\n\n    default:\n      throw new Error(\"Invalid state \\\"\" + data.state + \"\\\"\");\n  }\n}\n/**\n * Manages state for an immutable async loaded list data structure, and provides convenience methods to\n * update the data over time. Manages loading and error states, pagination, and sorting.\n */\n\n\nexport function useAsyncList(options) {\n  const {\n    load,\n    sort,\n    initialSelectedKeys,\n    initialSortDescriptor,\n    getKey = item => item.id || item.key\n  } = options;\n  let [data, dispatch] = useReducer($ebfe0ef2c160f1de1367205924a0b01e$var$reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor\n  });\n\n  const dispatchFetch = async (action, fn) => {\n    let abortController = new AbortController();\n\n    try {\n      var _action$sortDescripto4;\n\n      dispatch(_babelRuntimeHelpersEsmExtends({}, action, {\n        abortController\n      }));\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: (_action$sortDescripto4 = action.sortDescriptor) != null ? _action$sortDescripto4 : data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null\n      });\n      dispatch(_babelRuntimeHelpersEsmExtends({\n        type: 'success'\n      }, response, {\n        abortController\n      }));\n    } catch (e) {\n      dispatch({\n        type: 'error',\n        error: e,\n        abortController\n      });\n    }\n  };\n\n  useEffect(() => {\n    dispatchFetch({\n      type: 'loading'\n    }, load); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return _babelRuntimeHelpersEsmExtends({\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting',\n    error: data.error,\n\n    getItem(key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n\n    reload() {\n      dispatchFetch({\n        type: 'loading'\n      }, load);\n    },\n\n    loadMore() {\n      // Ignore if already loading more.\n      if (data.state === 'loadingMore' || data.cursor == null) {\n        return;\n      }\n\n      dispatchFetch({\n        type: 'loadingMore'\n      }, load);\n    },\n\n    sort(sortDescriptor) {\n      dispatchFetch({\n        type: 'sorting',\n        sortDescriptor\n      }, sort || load);\n    }\n\n  }, $b778f1542e2cf1e9d9f1c7276a173aec$export$createListActions(_babelRuntimeHelpersEsmExtends({}, options, {\n    getKey\n  }), fn => {\n    dispatch({\n      type: 'update',\n      updater: fn\n    });\n  }));\n}\n/**\n * Manages state for an immutable tree data structure, and provides convenience methods to\n * update the data over time.\n */\n\nexport function useTreeData(options) {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = item => item.id || item.key,\n    getChildren = item => item.children || []\n  } = options;\n  let map = useMemo(() => new Map(), []); // We only want to compute this on initial render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  let initialNodes = useMemo(() => buildTree(initialItems), []);\n  let [items, setItems] = useState(initialNodes);\n  let [selectedKeys, setSelectedKeys] = useState(new Set(initialSelectedKeys || []));\n\n  function buildTree(initialItems, parentKey) {\n    return initialItems.map(item => {\n      let node = {\n        key: getKey(item),\n        parentKey: parentKey,\n        value: item,\n        children: null\n      };\n      node.children = buildTree(getChildren(item), node.key);\n      map.set(node.key, node);\n      return node;\n    });\n  }\n\n  function updateTree(items, key, update) {\n    let node = map.get(key);\n\n    if (!node) {\n      return items;\n    } // Create a new node. If null, then delete the node, otherwise replace.\n\n\n    let newNode = update(node);\n\n    if (newNode == null) {\n      deleteNode(node);\n    } else {\n      map.set(key, newNode);\n    } // Walk up the tree and update each parent to refer to the new chilren.\n\n\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n      let children = nextParent.children;\n\n      if (newNode == null) {\n        children = children.filter(c => c !== node);\n      }\n\n      copy.children = children.map(child => {\n        if (child === node) {\n          return newNode;\n        }\n\n        return child;\n      });\n      map.set(copy.key, copy);\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) {\n      items = items.filter(c => c !== node);\n    }\n\n    return items.map(item => {\n      if (item === node) {\n        return newNode;\n      }\n\n      return item;\n    });\n  }\n\n  function deleteNode(node) {\n    map.delete(node.key);\n\n    for (let child of node.children) {\n      deleteNode(child);\n    }\n  }\n\n  return {\n    items,\n    selectedKeys,\n    setSelectedKeys,\n\n    getItem(key) {\n      return map.get(key);\n    },\n\n    insert(parentKey, index) {\n      for (var _len = arguments.length, values = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        values[_key - 2] = arguments[_key];\n      }\n\n      setItems(items => {\n        let nodes = buildTree(values, parentKey); // If parentKey is null, insert into the root.\n\n        if (parentKey == null) {\n          return [...items.slice(0, index), ...nodes, ...items.slice(index)];\n        } // Otherwise, update the parent node and its ancestors.\n\n\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [...parentNode.children.slice(0, index), ...nodes, ...parentNode.children.slice(index)]\n        }));\n      });\n    },\n\n    insertBefore(key) {\n      let node = map.get(key);\n\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n\n      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        values[_key2 - 1] = arguments[_key2];\n      }\n\n      this.insert(parentNode == null ? void 0 : parentNode.key, index, ...values);\n    },\n\n    insertAfter(key) {\n      let node = map.get(key);\n\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n\n      for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        values[_key3 - 1] = arguments[_key3];\n      }\n\n      this.insert(parentNode == null ? void 0 : parentNode.key, index + 1, ...values);\n    },\n\n    prepend(parentKey) {\n      for (var _len4 = arguments.length, values = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        values[_key4 - 1] = arguments[_key4];\n      }\n\n      this.insert(parentKey, 0, ...values);\n    },\n\n    append(parentKey) {\n      for (var _len5 = arguments.length, values = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        values[_key5 - 1] = arguments[_key5];\n      }\n\n      if (parentKey == null) {\n        this.insert(null, items.length, ...values);\n      } else {\n        let parentNode = map.get(parentKey);\n\n        if (!parentNode) {\n          return;\n        }\n\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n\n    remove() {\n      let newItems = items;\n\n      for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        keys[_key6] = arguments[_key6];\n      }\n\n      for (let key of keys) {\n        newItems = updateTree(newItems, key, () => null);\n      }\n\n      setItems(newItems);\n      let selection = new Set(selectedKeys);\n\n      for (let key of selectedKeys) {\n        if (!map.has(key)) {\n          selection.delete(key);\n        }\n      }\n\n      setSelectedKeys(selection);\n    },\n\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n\n    move(key, toParentKey, index) {\n      setItems(items => {\n        let node = map.get(key);\n\n        if (!node) {\n          return items;\n        }\n\n        items = updateTree(items, key, () => null);\n        return updateTree(items, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [...parentNode.children.slice(0, index), node, ...parentNode.children.slice(index)]\n        }));\n      });\n    },\n\n    update(oldKey, newValue) {\n      setItems(items => updateTree(items, oldKey, oldNode => {\n        let node = {\n          key: oldNode.key,\n          parentKey: oldNode.key,\n          value: newValue,\n          children: null\n        };\n        node.children = buildTree(getChildren(newValue), node.key);\n        return node;\n      }));\n    }\n\n  };\n}","map":{"version":3,"sources":["packages/@react-stately/data/src/useListData.ts","packages/@react-stately/data/src/useAsyncList.ts","packages/@react-stately/data/src/useTreeData.ts"],"names":["initialItems","getKey","item","key","useState","items","selectedKeys","initialSelectedKeys","createListActions","getItem","state","values","setSelectedKeys","dispatch","insert","insertBefore","index","insertAfter","prepend","append","remove","keys","keySet","selection","removeSelectedItems","move","copy","update","data","action","sortDescriptor","abortController","cursor","error","useReducer","initialSortDescriptor","dispatchFetch","response","fn","signal","type","useEffect","isLoading","reload","loadMore","sort","updater","getChildren","map","useMemo","initialNodes","buildTree","node","parentKey","value","children","newNode","deleteNode","nextParent","c","child","setItems","nodes","updateTree","parentNode","newItems","oldNode"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useState} from 'react';\nimport {Selection} from '@react-types/shared';\n\ninterface ListOptions<T> {\n  /** Initial items in the list. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: 'all' | Iterable<Key>,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key\n}\n\nexport interface ListData<T> {\n  /** The items in the list. */\n  items: T[],\n\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Selection): void,\n\n  /**\n   * Gets an item from the list by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): T,\n\n  /**\n   * Inserts items into the list at the given index.\n   * @param index - The index to insert into.\n   * @param values - The values to insert.\n   */\n  insert(index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends items to the list.\n   * @param values - The values to insert.\n   */\n  append(...values: T[]): void,\n\n  /**\n   * Prepends items to the list.\n   * @param value - The value to insert.\n   */\n  prepend(...values: T[]): void,\n\n  /**\n   * Removes items from the list by their keys.\n   * @param keys - The keys of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the list that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the list.\n   * @param key - The key of the item to move.\n   * @param toIndex - The index to move the item to.\n   */\n  move(key: Key, toIndex: number): void,\n\n  /**\n   * Updates an item in the list.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\nexport interface ListState<T> {\n  items: T[],\n  selectedKeys: Selection\n}\n\n/**\n * Manages state for an immutable list data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useListData<T>(options: ListOptions<T>): ListData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key\n  } = options;\n  let [state, setState] = useState<ListState<T>>({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || [])\n  });\n\n  return {\n    ...state,\n    ...createListActions({getKey}, setState),\n    getItem(key: Key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n  };\n}\n\nfunction insert<T>(state: ListState<T>, index: number, ...values: T[]): ListState<T> {\n  return {\n    ...state,\n    items: [\n      ...state.items.slice(0, index),\n      ...values,\n      ...state.items.slice(index)\n    ]\n  };\n}\n\nexport function createListActions<T>(opts: ListOptions<T>, dispatch: (updater: (state: ListState<T>) => ListState<T>) => void): Omit<ListData<T>, 'items' | 'selectedKeys' | 'getItem'> {\n  let {getKey} = opts;\n  return {\n    setSelectedKeys(selectedKeys: Selection) {\n      dispatch(state => ({\n        ...state,\n        selectedKeys\n      }));\n    },\n    insert(index: number, ...values: T[]) {\n      dispatch(state => insert(state, index, ...values));\n    },\n    insertBefore(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index, ...values);\n      });\n    },\n    insertAfter(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index + 1, ...values);\n      });\n    },\n    prepend(...values: T[]) {\n      dispatch(state => insert(state, 0, ...values));\n    },\n    append(...values: T[]) {\n      dispatch(state => insert(state, state.items.length, ...values));\n    },\n    remove(...keys: Key[]) {\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n\n        let selection = new Set(state.selectedKeys);\n        for (let key of keys) {\n          selection.delete(key);\n        }\n\n        return {\n          ...state,\n          items,\n          selectedKeys: selection\n        };\n      });\n    },\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') {\n          return {\n            ...state,\n            items: [],\n            selectedKeys: new Set()\n          };\n        }\n\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return {\n          ...state,\n          items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n    move(key: Key, toIndex: number) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        let copy = state.items.slice();\n        let [item] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item);\n        return {\n          ...state,\n          items: copy\n        };\n      });\n    },\n    update(key: Key, newValue: T) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        return {\n          ...state,\n          items: [\n            ...state.items.slice(0, index),\n            newValue,\n            ...state.items.slice(index + 1)\n          ]\n        };\n      });\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createListActions, ListData, ListState} from './useListData';\nimport {Key, Reducer, useEffect, useReducer} from 'react';\nimport {Selection, SortDescriptor} from '@react-types/shared';\n\ninterface AsyncListOptions<T, C> {\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** The initial sort descriptor. */\n  initialSortDescriptor?: SortDescriptor,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that loads the data for the items in the list. */\n  load: AsyncListLoadFunction<T, C>,\n  /**\n   * An optional function that performs sorting. If not provided,\n   * then `sortDescriptor` is passed to the `load` function.\n   */\n  sort?: AsyncListLoadFunction<T, C>\n}\n\ntype AsyncListLoadFunction<T, C> = (state: AsyncListLoadOptions<T, C>) => Promise<AsyncListStateUpdate<T, C>>;\ninterface AsyncListLoadOptions<T, C> {\n  /** The items currently in the list. */\n  items: T[],\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n  /** The current sort descriptor for the list. */\n  sortDescriptor: SortDescriptor,\n  /** An abort signal used to notify the load function that the request has been aborted. */\n  signal: AbortSignal,\n  /** The pagination cursor returned from the last page load. */\n  cursor?: C\n}\n\ninterface AsyncListStateUpdate<T, C> {\n  /** The new items to append to the list. */\n  items: Iterable<T>,\n  /** The keys to add to the selection. */\n  selectedKeys?: Iterable<Key>,\n  /** The sort descriptor to set. */\n  sortDescriptor?: SortDescriptor,\n  /** The pagination cursor to be used for the next page load. */\n  cursor?: C\n}\n\ninterface AsyncListState<T, C> extends ListState<T> {\n  state: 'loading' | 'sorting' | 'loadingMore' | 'error' | 'idle',\n  items: T[],\n  // disabledKeys?: Iterable<Key>,\n  selectedKeys: Selection,\n  // selectedKey?: Key,\n  // expandedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  cursor?: C\n}\n\ntype ActionType = 'success' | 'error' | 'loading' | 'loadingMore' | 'sorting' | 'update';\ninterface Action<T, C> {\n  type: ActionType,\n  items?: Iterable<T>,\n  selectedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  updater?: (state: ListState<T>) => ListState<T>,\n  cursor?: C\n}\n\ninterface AsyncListData<T> extends ListData<T> {\n  /** Whether data is currently being loaded. */\n  isLoading: boolean,\n  /** If loading data failed, then this contains the error that occurred. */\n  error?: Error,\n  // disabledKeys?: Set<Key>,\n  // selectedKey?: Key,\n  // expandedKeys?: Set<Key>,\n  /** The current sort descriptor for the list. */\n  sortDescriptor?: SortDescriptor,\n\n  /** Reloads the data in the list. */\n  reload(): void,\n  /** Loads the next page of data in the list. */\n  loadMore(): void,\n  /** Triggers sorting for the list. */\n  sort(descriptor: SortDescriptor): void\n}\n\nfunction reducer<T, C>(data: AsyncListState<T, C>, action: Action<T, C>): AsyncListState<T, C> {\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n          return {\n            ...data,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: new Set(action.selectedKeys ?? data.selectedKeys),\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys: new Set([...data.selectedKeys, ...(action.selectedKeys ?? [])]),\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            state: 'loading',\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\n\n/**\n * Manages state for an immutable async loaded list data structure, and provides convenience methods to\n * update the data over time. Manages loading and error states, pagination, and sorting.\n */\nexport function useAsyncList<T, C = string>(options: AsyncListOptions<T, C>): AsyncListData<T> {\n  const {\n    load,\n    sort,\n    initialSelectedKeys,\n    initialSortDescriptor,\n    getKey = (item: any) => item.id || item.key\n  } = options;\n\n  let [data, dispatch] = useReducer<Reducer<AsyncListState<T, C>, Action<T, C>>>(reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor\n  });\n\n  const dispatchFetch = async (action: Action<T, C>, fn: AsyncListLoadFunction<T, C>) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({...action, abortController});\n\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null\n      });\n      dispatch({type: 'success', ...response, abortController});\n    } catch (e) {\n      dispatch({type: 'error', error: e, abortController});\n    }\n  };\n\n  useEffect(() => {\n    dispatchFetch({type: 'loading'}, load);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting',\n    error: data.error,\n    getItem(key: Key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({type: 'loading'}, load);\n    },\n    loadMore() {\n      // Ignore if already loading more.\n      if (data.state === 'loadingMore' || data.cursor == null) {\n        return;\n      }\n\n      dispatchFetch({type: 'loadingMore'}, load);\n    },\n    sort(sortDescriptor: SortDescriptor) {\n      dispatchFetch({type: 'sorting', sortDescriptor}, sort || load);\n    },\n    ...createListActions({...options, getKey}, fn => {\n      dispatch({type: 'update', updater: fn});\n    })\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useState} from 'react';\n\ninterface TreeOptions<T extends object> {\n  /** Initial root items in the tree. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns the children for an item object. */\n  getChildren?: (item: T) => T[]\n}\n\ninterface TreeNode<T extends object> {\n  /** A unique key for the tree node. */\n  key: Key,\n  /** The key of the parent node. */\n  parentKey: Key,\n  /** The value object for the tree node. */\n  value: T,\n  /** Children of the tree node. */\n  children: TreeNode<T>[]\n}\n\ninterface TreeData<T extends object> {\n  /** The root nodes in the tree. */\n  items: TreeNode<T>[],\n\n  /** The keys of the currently selected items in the tree. */\n  selectedKeys: Set<Key>,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Set<Key>): void,\n\n  /**\n   * Gets a node from the tree by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): TreeNode<T>,\n\n  /**\n   * Inserts an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param index - The index within the parent to insert into.\n   * @param value - The value to insert.\n   */\n  insert(parentKey: Key | null, index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  append(parentKey: Key | null, ...values: T[]): void,\n\n  /**\n   * Prepends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  prepend(parentKey: Key | null, ...value: T[]): void,\n\n  /**\n   * Removes an item from the tree by its key.\n   * @param key - The key of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the tree that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the tree.\n   * @param key - The key of the item to move.\n   * @param toParentKey - The key of the new parent to insert into.\n   * @param index - The index within the new parent to insert at.\n   */\n  move(key: Key, toParentKey: Key, index: number): void,\n\n  /**\n   * Updates an item in the tree.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\n/**\n * Manages state for an immutable tree data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useTreeData<T extends object>(options: TreeOptions<T>): TreeData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    getChildren = (item: any) => item.children || []\n  } = options;\n  let map = useMemo(() => new Map<Key, TreeNode<T>>(), []);\n\n  // We only want to compute this on initial render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  let initialNodes = useMemo(() => buildTree(initialItems), []);\n  let [items, setItems] = useState(initialNodes);\n  let [selectedKeys, setSelectedKeys] = useState(new Set<Key>(initialSelectedKeys || []));\n\n  function buildTree(initialItems: T[], parentKey?: Key | null) {\n    return initialItems.map(item => {\n      let node: TreeNode<T> = {\n        key: getKey(item),\n        parentKey: parentKey,\n        value: item,\n        children: null\n      };\n\n      node.children = buildTree(getChildren(item), node.key);\n      map.set(node.key, node);\n      return node;\n    });\n  }\n\n  function updateTree(items: TreeNode<T>[], key: Key, update: (node: TreeNode<T>) => TreeNode<T>) {\n    let node = map.get(key);\n    if (!node) {\n      return items;\n    }\n\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) {\n      deleteNode(node);\n    } else {\n      map.set(key, newNode);\n    }\n\n    // Walk up the tree and update each parent to refer to the new chilren.\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy: TreeNode<T> = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n\n      let children = nextParent.children;\n      if (newNode == null) {\n        children = children.filter(c => c !== node);\n      }\n\n      copy.children = children.map(child => {\n        if (child === node) {\n          return newNode;\n        }\n\n        return child;\n      });\n\n      map.set(copy.key, copy);\n\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) {\n      items = items.filter(c => c !== node);\n    }\n\n    return items.map(item => {\n      if (item === node) {\n        return newNode;\n      }\n\n      return item;\n    });\n  }\n\n  function deleteNode(node: TreeNode<T>) {\n    map.delete(node.key);\n    for (let child of node.children) {\n      deleteNode(child);\n    }\n  }\n\n  return {\n    items,\n    selectedKeys,\n    setSelectedKeys,\n    getItem(key: Key) {\n      return map.get(key);\n    },\n    insert(parentKey: Key | null, index: number, ...values: T[]) {\n      setItems(items => {\n        let nodes = buildTree(values, parentKey);\n\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) {\n          return [\n            ...items.slice(0, index),\n            ...nodes,\n            ...items.slice(index)\n          ];\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            ...nodes,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    insertBefore(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index, ...values);\n    },\n    insertAfter(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index + 1, ...values);\n    },\n    prepend(parentKey: Key | null, ...values: T[]) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey: Key | null, ...values: T[]) {\n      if (parentKey == null) {\n        this.insert(null, items.length, ...values);\n      } else {\n        let parentNode = map.get(parentKey);\n        if (!parentNode) {\n          return;\n        }\n\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove(...keys: Key[]) {\n      let newItems = items;\n      for (let key of keys) {\n        newItems = updateTree(newItems, key, () => null);\n      }\n\n      setItems(newItems);\n\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) {\n        if (!map.has(key)) {\n          selection.delete(key);\n        }\n      }\n\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key: Key, toParentKey: Key, index: number) {\n      setItems(items => {\n        let node = map.get(key);\n        if (!node) {\n          return items;\n        }\n\n        items = updateTree(items, key, () => null);\n        return updateTree(items, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            node,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    update(oldKey: Key, newValue: T) {\n      setItems(items => updateTree(items, oldKey, oldNode => {\n        let node: TreeNode<T> = {\n          key: oldNode.key,\n          parentKey: oldNode.key,\n          value: newValue,\n          children: null\n        };\n\n        node.children = buildTree(getChildren(newValue), node.key);\n        return node;\n      }));\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}