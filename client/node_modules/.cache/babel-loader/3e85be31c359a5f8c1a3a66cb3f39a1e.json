{"ast":null,"code":"import { Layout, LayoutInfo, Rect, Size } from \"@react-stately/virtualizer\";\nconst $f5ce3e4c61ac6cf0e14287baf8f147b$var$DEFAULT_HEIGHT = 48;\n/**\n * The ListLayout class is an implementation of a collection view {@link Layout}\n * it is used for creating lists and lists with indented sub-lists.\n *\n * To configure a ListLayout, you can use the properties to define the\n * layouts and/or use the method for defining indentation.\n * The {@link ListKeyboardDelegate} extends the existing collection view\n * delegate with an additional method to do this (it uses the same delegate object as\n * the collection view itself).\n */\n\nexport class ListLayout extends Layout {\n  /**\n   * Creates a new ListLayout with options. See the list of properties below for a description\n   * of the options that can be provided.\n   */\n  constructor(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    super();\n    this.rowHeight = void 0;\n    this.estimatedRowHeight = void 0;\n    this.headingHeight = void 0;\n    this.estimatedHeadingHeight = void 0;\n    this.padding = void 0;\n    this.indentationForItem = void 0;\n    this.layoutInfos = void 0;\n    this.layoutNodes = void 0;\n    this.contentSize = void 0;\n    this.collection = void 0;\n    this.disabledKeys = new Set();\n    this.isLoading = void 0;\n    this.lastWidth = void 0;\n    this.lastCollection = void 0;\n    this.rootNodes = void 0;\n    this.collator = void 0;\n    this.invalidateEverything = void 0;\n    this.rowHeight = options.rowHeight;\n    this.estimatedRowHeight = options.estimatedRowHeight;\n    this.headingHeight = options.headingHeight;\n    this.estimatedHeadingHeight = options.estimatedHeadingHeight;\n    this.padding = options.padding || 0;\n    this.indentationForItem = options.indentationForItem;\n    this.collator = options.collator;\n    this.layoutInfos = new Map();\n    this.layoutNodes = new Map();\n    this.rootNodes = [];\n    this.lastWidth = 0;\n    this.lastCollection = null;\n  }\n\n  getLayoutInfo(key) {\n    return this.layoutInfos.get(key);\n  }\n\n  getVisibleLayoutInfos(rect) {\n    let res = [];\n\n    let addNodes = nodes => {\n      for (let node of nodes) {\n        if (this.isVisible(node, rect)) {\n          res.push(node.layoutInfo);\n\n          if (node.header) {\n            res.push(node.header);\n          }\n\n          if (node.children) {\n            addNodes(node.children);\n          }\n        }\n      }\n    };\n\n    addNodes(this.rootNodes);\n    return res;\n  }\n\n  isVisible(node, rect) {\n    return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky;\n  }\n\n  validate(invalidationContext) {\n    // Invalidate cache if the size of the collection changed.\n    // In this case, we need to recalculate the entire layout.\n    this.invalidateEverything = invalidationContext.sizeChanged;\n    this.collection = this.virtualizer.collection;\n    this.rootNodes = this.buildCollection();\n    this.lastWidth = this.virtualizer.visibleRect.width;\n    this.lastCollection = this.collection;\n  }\n\n  buildCollection() {\n    let y = this.padding;\n    let nodes = [];\n\n    for (let node of this.collection) {\n      let layoutNode = this.buildChild(node, 0, y);\n      y = layoutNode.layoutInfo.rect.maxY;\n      nodes.push(layoutNode);\n    }\n\n    if (nodes.length === 0) {\n      let rect = new Rect(0, y, this.virtualizer.visibleRect.width, this.rowHeight || this.estimatedRowHeight);\n      let placeholder = new LayoutInfo('placeholder', 'placeholder', rect);\n      this.layoutInfos.set('placeholder', placeholder);\n      nodes.push({\n        layoutInfo: placeholder\n      });\n      y = placeholder.rect.maxY;\n    }\n\n    if (this.isLoading) {\n      let rect = new Rect(0, y, this.virtualizer.visibleRect.width, 40);\n      let loader = new LayoutInfo('loader', 'loader', rect);\n      this.layoutInfos.set('loader', loader);\n      nodes.push({\n        layoutInfo: loader\n      });\n      y = loader.rect.maxY;\n    }\n\n    this.contentSize = new Size(this.virtualizer.visibleRect.width, y + this.padding);\n    return nodes;\n  }\n\n  buildChild(node, x, y) {\n    let cached = this.layoutNodes.get(node.key);\n\n    if (!this.invalidateEverything && cached && cached.node === node && y === (cached.header || cached.layoutInfo).rect.y) {\n      return cached;\n    }\n\n    let layoutNode = this.buildNode(node, x, y);\n    layoutNode.node = node;\n    layoutNode.layoutInfo.parentKey = node.parentKey || null;\n    this.layoutInfos.set(layoutNode.layoutInfo.key, layoutNode.layoutInfo);\n\n    if (layoutNode.header) {\n      this.layoutInfos.set(layoutNode.header.key, layoutNode.header);\n    } // Remove deleted child layout nodes from key mapping.\n\n\n    if (cached) {\n      let childKeys = new Set();\n\n      if (layoutNode.children) {\n        for (let child of layoutNode.children) {\n          childKeys.add(child.layoutInfo.key);\n        }\n      }\n\n      if (cached.children) {\n        for (let child of cached.children) {\n          if (!childKeys.has(child.layoutInfo.key)) {\n            this.removeLayoutNode(child);\n          }\n        }\n      }\n    }\n\n    this.layoutNodes.set(node.key, layoutNode);\n    return layoutNode;\n  }\n\n  removeLayoutNode(layoutNode) {\n    this.layoutNodes.delete(layoutNode.layoutInfo.key);\n    this.layoutInfos.delete(layoutNode.layoutInfo.key);\n\n    if (layoutNode.header) {\n      this.layoutInfos.delete(layoutNode.header.key);\n    }\n\n    if (layoutNode.children) {\n      for (let child of layoutNode.children) {\n        if (this.layoutNodes.get(child.layoutInfo.key) === child) {\n          this.removeLayoutNode(child);\n        }\n      }\n    }\n  }\n\n  buildNode(node, x, y) {\n    switch (node.type) {\n      case 'section':\n        return this.buildSection(node, x, y);\n\n      case 'item':\n        return this.buildItem(node, x, y);\n    }\n  }\n\n  buildSection(node, x, y) {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.headingHeight;\n    let isEstimated = false; // If no explicit height is available, use an estimated height.\n\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n\n      if (previousLayoutNode && previousLayoutNode.header) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutNode.header.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.header.estimatedSize;\n      } else {\n        rectHeight = node.rendered ? this.estimatedHeadingHeight : 0;\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = $f5ce3e4c61ac6cf0e14287baf8f147b$var$DEFAULT_HEIGHT;\n    }\n\n    let headerRect = new Rect(0, y, width, rectHeight);\n    let header = new LayoutInfo('header', node.key + ':header', headerRect);\n    header.estimatedSize = isEstimated;\n    header.parentKey = node.key;\n    y += header.rect.height;\n    let rect = new Rect(0, y, width, 0);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    let startY = y;\n    let children = [];\n\n    for (let child of node.childNodes) {\n      let layoutNode = this.buildChild(child, x, y);\n      y = layoutNode.layoutInfo.rect.maxY;\n      children.push(layoutNode);\n    }\n\n    rect.height = y - startY;\n    return {\n      header,\n      layoutInfo,\n      children\n    };\n  }\n\n  buildItem(node, x, y) {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.rowHeight;\n    let isEstimated = false; // If no explicit height is available, use an estimated height.\n\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n\n      if (previousLayoutNode) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        rectHeight = this.estimatedRowHeight;\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = $f5ce3e4c61ac6cf0e14287baf8f147b$var$DEFAULT_HEIGHT;\n    }\n\n    if (typeof this.indentationForItem === 'function') {\n      x += this.indentationForItem(this.collection, node.key) || 0;\n    }\n\n    let rect = new Rect(x, y, width - x, rectHeight);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo\n    };\n  }\n\n  updateItemSize(key, size) {\n    let layoutInfo = this.layoutInfos.get(key);\n    layoutInfo.estimatedSize = false;\n\n    if (layoutInfo.rect.height !== size.height) {\n      // Copy layout info rather than mutating so that later caches are invalidated.\n      let newLayoutInfo = layoutInfo.copy();\n      newLayoutInfo.rect.height = size.height;\n      this.layoutInfos.set(key, newLayoutInfo); // Invalidate layout for this layout node and all parents\n\n      this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n      let node = this.collection.getItem(layoutInfo.parentKey);\n\n      while (node) {\n        this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n        node = this.collection.getItem(node.parentKey);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  updateLayoutNode(key, oldLayoutInfo, newLayoutInfo) {\n    let n = this.layoutNodes.get(key);\n\n    if (n) {\n      // Invalidate by clearing node.\n      n.node = null; // Replace layout info in LayoutNode\n\n      if (n.header === oldLayoutInfo) {\n        n.header = newLayoutInfo;\n      } else if (n.layoutInfo === oldLayoutInfo) {\n        n.layoutInfo = newLayoutInfo;\n      }\n    }\n  }\n\n  getContentSize() {\n    return this.contentSize;\n  }\n\n  getKeyAbove(key) {\n    let collection = this.collection;\n    key = collection.getKeyBefore(key);\n\n    while (key != null) {\n      let item = collection.getItem(key);\n\n      if (item.type === 'item' && !this.disabledKeys.has(item.key)) {\n        return key;\n      }\n\n      key = collection.getKeyBefore(key);\n    }\n  }\n\n  getKeyBelow(key) {\n    let collection = this.collection;\n    key = collection.getKeyAfter(key);\n\n    while (key != null) {\n      let item = collection.getItem(key);\n\n      if (item.type === 'item' && !this.disabledKeys.has(item.key)) {\n        return key;\n      }\n\n      key = collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyPageAbove(key) {\n    let layoutInfo = this.getLayoutInfo(key);\n\n    if (layoutInfo) {\n      let pageY = Math.max(0, layoutInfo.rect.y + layoutInfo.rect.height - this.virtualizer.visibleRect.height);\n\n      while (layoutInfo && layoutInfo.rect.y > pageY && layoutInfo) {\n        let keyAbove = this.getKeyAbove(layoutInfo.key);\n        layoutInfo = this.getLayoutInfo(keyAbove);\n      }\n\n      if (layoutInfo) {\n        return layoutInfo.key;\n      }\n    }\n\n    return this.getFirstKey();\n  }\n\n  getKeyPageBelow(key) {\n    let layoutInfo = this.getLayoutInfo(key != null ? key : this.getFirstKey());\n\n    if (layoutInfo) {\n      let pageY = Math.min(this.virtualizer.contentSize.height, layoutInfo.rect.y - layoutInfo.rect.height + this.virtualizer.visibleRect.height);\n\n      while (layoutInfo && layoutInfo.rect.y < pageY) {\n        let keyBelow = this.getKeyBelow(layoutInfo.key);\n        layoutInfo = this.getLayoutInfo(keyBelow);\n      }\n\n      if (layoutInfo) {\n        return layoutInfo.key;\n      }\n    }\n\n    return this.getLastKey();\n  }\n\n  getFirstKey() {\n    let collection = this.collection;\n    let key = collection.getFirstKey();\n\n    while (key != null) {\n      let item = collection.getItem(key);\n\n      if (item.type === 'item' && !this.disabledKeys.has(item.key)) {\n        return key;\n      }\n\n      key = collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let collection = this.collection;\n    let key = collection.getLastKey();\n\n    while (key != null) {\n      let item = collection.getItem(key);\n\n      if (item.type === 'item' && !this.disabledKeys.has(item.key)) {\n        return key;\n      }\n\n      key = collection.getKeyBefore(key);\n    }\n  }\n\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  } // getDragTarget(point: Point): DragTarget {\n  //   let visible = this.getVisibleLayoutInfos(new Rect(point.x, point.y, 1, 1));\n  //   if (visible.length > 0) {\n  //     visible = visible.sort((a, b) => b.zIndex - a.zIndex);\n  //     return {\n  //       type: 'item',\n  //       key: visible[0].key\n  //     };\n  //   }\n  //   return null;\n  // }\n  // getDropTarget(point: Point): DropTarget {\n  //   let key = this.virtualizer.keyAtPoint(point);\n  //   if (key) {\n  //     return {\n  //       type: 'item',\n  //       key,\n  //       dropPosition: DropPosition.ON\n  //     };\n  //   }\n  //   return null;\n  // }\n\n\n  getInitialLayoutInfo(layoutInfo) {\n    layoutInfo.opacity = 0;\n    layoutInfo.transform = 'scale3d(0.8, 0.8, 0.8)';\n    return layoutInfo;\n  }\n\n  getFinalLayoutInfo(layoutInfo) {\n    layoutInfo.opacity = 0;\n    layoutInfo.transform = 'scale3d(0.8, 0.8, 0.8)';\n    return layoutInfo;\n  }\n\n}\nexport class TableLayout extends ListLayout {\n  constructor(options) {\n    super(options);\n    this.collection = void 0;\n    this.lastCollection = void 0;\n    this.columnWidths = void 0;\n    this.stickyColumnIndices = void 0;\n    this.getDefaultWidth = void 0;\n    this.getDefaultWidth = options.getDefaultWidth;\n  }\n\n  buildCollection() {\n    // If columns changed, clear layout cache.\n    if (!this.lastCollection || this.collection.columns.length !== this.lastCollection.columns.length || this.collection.columns.some((c, i) => c.key !== this.lastCollection.columns[i].key)) {\n      // Invalidate everything in this layout pass. Will be reset in ListLayout on the next pass.\n      this.invalidateEverything = true;\n    }\n\n    this.buildColumnWidths();\n    let header = this.buildHeader();\n    let body = this.buildBody(0);\n    body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);\n    this.contentSize = new Size(body.layoutInfo.rect.width, body.layoutInfo.rect.maxY);\n    return [header, body];\n  }\n\n  buildColumnWidths() {\n    this.columnWidths = new Map();\n    this.stickyColumnIndices = []; // Pass 1: set widths for all explicitly defined columns.\n\n    let remainingColumns = new Set();\n    let remainingSpace = this.virtualizer.visibleRect.width;\n\n    for (let column of this.collection.columns) {\n      var _ref, _props$width;\n\n      let props = column.props;\n      let width = (_ref = (_props$width = props.width) != null ? _props$width : props.defaultWidth) != null ? _ref : this.getDefaultWidth(props);\n\n      if (width != null) {\n        let w = this.parseWidth(width);\n        this.columnWidths.set(column.key, w);\n        remainingSpace -= w;\n      } else {\n        remainingColumns.add(column);\n      } // The selection cell and any other sticky columns always need to be visible.\n      // In addition, row headers need to be in the DOM for accessibility labeling.\n\n\n      if (column.props.isSelectionCell || this.collection.rowHeaderColumnKeys.has(column.key)) {\n        this.stickyColumnIndices.push(column.index);\n      }\n    } // Pass 2: if there are remaining columns, then distribute the remaining space evenly.\n\n\n    if (remainingColumns.size > 0) {\n      let columnWidth = remainingSpace / (this.collection.columns.length - this.columnWidths.size);\n\n      for (let column of remainingColumns) {\n        let props = column.props;\n        let minWidth = props.minWidth != null ? this.parseWidth(props.minWidth) : 75;\n        let maxWidth = props.maxWidth != null ? this.parseWidth(props.maxWidth) : Infinity;\n        let width = Math.max(minWidth, Math.min(maxWidth, columnWidth));\n        this.columnWidths.set(column.key, width);\n        remainingSpace -= width;\n\n        if (width !== columnWidth) {\n          columnWidth = remainingSpace / (this.collection.columns.length - this.columnWidths.size);\n        }\n      }\n    }\n  }\n\n  parseWidth(width) {\n    if (typeof width === 'string') {\n      let match = width.match(/^(\\d+)%$/);\n\n      if (!match) {\n        throw new Error('Only percentages are supported as column widths');\n      }\n\n      return this.virtualizer.visibleRect.width * (parseInt(match[1], 10) / 100);\n    }\n\n    return width;\n  }\n\n  buildHeader() {\n    let rect = new Rect(0, 0, 0, 0);\n    let layoutInfo = new LayoutInfo('header', 'header', rect);\n    let y = 0;\n    let width = 0;\n    let children = [];\n\n    for (let headerRow of this.collection.headerRows) {\n      let layoutNode = this.buildChild(headerRow, 0, y);\n      layoutNode.layoutInfo.parentKey = 'header';\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      children.push(layoutNode);\n    }\n\n    rect.width = width;\n    rect.height = y;\n    this.layoutInfos.set('header', layoutInfo);\n    return {\n      layoutInfo,\n      children\n    };\n  }\n\n  buildHeaderRow(headerRow, x, y) {\n    let rect = new Rect(0, y, 0, 0);\n    let row = new LayoutInfo('headerrow', headerRow.key, rect);\n    let height = 0;\n    let columns = [];\n\n    for (let cell of headerRow.childNodes) {\n      let layoutNode = this.buildChild(cell, x, y);\n      layoutNode.layoutInfo.parentKey = row.key;\n      x = layoutNode.layoutInfo.rect.maxX;\n      height = Math.max(height, layoutNode.layoutInfo.rect.height);\n      columns.push(layoutNode);\n    }\n\n    this.setChildHeights(columns, height);\n    rect.height = height;\n    rect.width = x;\n    return {\n      layoutInfo: row,\n      children: columns\n    };\n  }\n\n  setChildHeights(children, height) {\n    for (let child of children) {\n      if (child.layoutInfo.rect.height !== height) {\n        // Need to copy the layout info before we mutate it.\n        child.layoutInfo = child.layoutInfo.copy();\n        this.layoutInfos.set(child.layoutInfo.key, child.layoutInfo);\n        child.layoutInfo.rect.height = height;\n      }\n    }\n  }\n\n  getColumnWidth(node) {\n    var _node$colspan;\n\n    let colspan = (_node$colspan = node.colspan) != null ? _node$colspan : 1;\n    let width = 0;\n\n    for (let i = 0; i < colspan; i++) {\n      let column = this.collection.columns[node.index + i];\n      width += this.columnWidths.get(column.key);\n    }\n\n    return width;\n  }\n\n  getEstimatedHeight(node, width, height, estimatedHeight) {\n    let isEstimated = false; // If no explicit height is available, use an estimated height.\n\n    if (height == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n\n      if (previousLayoutNode) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        height = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = curNode !== lastNode || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        height = estimatedHeight;\n        isEstimated = true;\n      }\n    }\n\n    return {\n      height,\n      isEstimated\n    };\n  }\n\n  buildColumn(node, x, y) {\n    var _node$props;\n\n    let width = this.getColumnWidth(node);\n    let {\n      height,\n      isEstimated\n    } = this.getEstimatedHeight(node, width, this.headingHeight, this.estimatedHeadingHeight);\n    let rect = new Rect(x, y, width, height);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = (_node$props = node.props) == null ? void 0 : _node$props.isSelectionCell;\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo\n    };\n  }\n\n  buildBody(y) {\n    let rect = new Rect(0, y, 0, 0);\n    let layoutInfo = new LayoutInfo('rowgroup', 'body', rect);\n    let startY = y;\n    let width = 0;\n    let children = [];\n\n    for (let node of this.collection.body.childNodes) {\n      let layoutNode = this.buildChild(node, 0, y);\n      layoutNode.layoutInfo.parentKey = 'body';\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      children.push(layoutNode);\n    } // TODO: not show the spinner at the bottom when sorting?\n\n\n    if (this.collection.body.props.isLoading) {\n      let rect = new Rect(0, y, width || this.virtualizer.visibleRect.width, children.length === 0 ? this.virtualizer.visibleRect.height : 60);\n      let loader = new LayoutInfo('loader', 'loader', rect);\n      loader.parentKey = 'body';\n      loader.isSticky = children.length === 0;\n      this.layoutInfos.set('loader', loader);\n      children.push({\n        layoutInfo: loader\n      });\n      y = loader.rect.maxY;\n      width = Math.max(width, rect.width);\n    } else if (children.length === 0) {\n      let rect = new Rect(0, y, this.virtualizer.visibleRect.width, this.virtualizer.visibleRect.height);\n      let empty = new LayoutInfo('empty', 'empty', rect);\n      empty.parentKey = 'body';\n      empty.isSticky = true;\n      this.layoutInfos.set('empty', empty);\n      children.push({\n        layoutInfo: empty\n      });\n      y = empty.rect.maxY;\n      width = Math.max(width, rect.width);\n    }\n\n    rect.width = width;\n    rect.height = y - startY;\n    this.layoutInfos.set('body', layoutInfo);\n    return {\n      layoutInfo,\n      children\n    };\n  }\n\n  buildNode(node, x, y) {\n    switch (node.type) {\n      case 'headerrow':\n        return this.buildHeaderRow(node, x, y);\n\n      case 'item':\n        return this.buildRow(node, x, y);\n\n      case 'column':\n      case 'placeholder':\n        return this.buildColumn(node, x, y);\n\n      case 'cell':\n        return this.buildCell(node, x, y);\n\n      default:\n        throw new Error('Unknown node type ' + node.type);\n    }\n  }\n\n  buildRow(node, x, y) {\n    let rect = new Rect(x, y, 0, 0);\n    let layoutInfo = new LayoutInfo('row', node.key, rect);\n    let children = [];\n    let height = 0;\n\n    for (let child of node.childNodes) {\n      let layoutNode = this.buildChild(child, x, y);\n      x = layoutNode.layoutInfo.rect.maxX;\n      height = Math.max(height, layoutNode.layoutInfo.rect.height);\n      children.push(layoutNode);\n    }\n\n    this.setChildHeights(children, height);\n    rect.width = x;\n    rect.height = height + 1; // +1 for bottom border\n\n    return {\n      layoutInfo,\n      children\n    };\n  }\n\n  buildCell(node, x, y) {\n    var _node$props2;\n\n    let width = this.getColumnWidth(node);\n    let {\n      height,\n      isEstimated\n    } = this.getEstimatedHeight(node, width, this.rowHeight, this.estimatedRowHeight);\n    let rect = new Rect(x, y, width, height);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = (_node$props2 = node.props) == null ? void 0 : _node$props2.isSelectionCell;\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo\n    };\n  }\n\n  getVisibleLayoutInfos(rect) {\n    let res = [];\n\n    for (let node of this.rootNodes) {\n      res.push(node.layoutInfo);\n      this.addVisibleLayoutInfos(res, node, rect);\n    }\n\n    return res;\n  }\n\n  addVisibleLayoutInfos(res, node, rect) {\n    if (!node.children || node.children.length === 0) {\n      return;\n    }\n\n    switch (node.layoutInfo.type) {\n      case 'header':\n        {\n          for (let child of node.children) {\n            res.push(child.layoutInfo);\n            this.addVisibleLayoutInfos(res, child, rect);\n          }\n\n          break;\n        }\n\n      case 'rowgroup':\n        {\n          let firstVisibleRow = this.binarySearch(node.children, rect.topLeft, 'y');\n          let lastVisibleRow = this.binarySearch(node.children, rect.bottomRight, 'y');\n\n          for (let i = firstVisibleRow; i <= lastVisibleRow; i++) {\n            res.push(node.children[i].layoutInfo);\n            this.addVisibleLayoutInfos(res, node.children[i], rect);\n          }\n\n          break;\n        }\n\n      case 'headerrow':\n      case 'row':\n        {\n          let firstVisibleCell = this.binarySearch(node.children, rect.topLeft, 'x');\n          let lastVisibleCell = this.binarySearch(node.children, rect.topRight, 'x');\n          let stickyIndex = 0;\n\n          for (let i = firstVisibleCell; i <= lastVisibleCell; i++) {\n            // Sticky columns and row headers are always in the DOM. Interleave these\n            // with the visible range so that they are in the right order.\n            if (stickyIndex < this.stickyColumnIndices.length) {\n              let idx = this.stickyColumnIndices[stickyIndex];\n\n              while (idx < i) {\n                res.push(node.children[idx].layoutInfo);\n                idx = this.stickyColumnIndices[stickyIndex++];\n              }\n            }\n\n            res.push(node.children[i].layoutInfo);\n          }\n\n          while (stickyIndex < this.stickyColumnIndices.length) {\n            let idx = this.stickyColumnIndices[stickyIndex++];\n            res.push(node.children[idx].layoutInfo);\n          }\n\n          break;\n        }\n\n      default:\n        throw new Error('Unknown node type ' + node.layoutInfo.type);\n    }\n  }\n\n  binarySearch(items, point, axis) {\n    let low = 0;\n    let high = items.length - 1;\n\n    while (low <= high) {\n      let mid = low + high >> 1;\n      let item = items[mid];\n\n      if (axis === 'x' && item.layoutInfo.rect.maxX < point.x || axis === 'y' && item.layoutInfo.rect.maxY < point.y) {\n        low = mid + 1;\n      } else if (axis === 'x' && item.layoutInfo.rect.x > point.x || axis === 'y' && item.layoutInfo.rect.y > point.y) {\n        high = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return Math.max(0, Math.min(items.length - 1, low));\n  }\n\n}","map":{"version":3,"sources":["packages/@react-stately/layout/src/ListLayout.ts","packages/@react-stately/layout/src/TableLayout.ts"],"names":["DEFAULT_HEIGHT","rowHeight","estimatedRowHeight","headingHeight","estimatedHeadingHeight","padding","indentationForItem","layoutInfos","layoutNodes","contentSize","collection","disabledKeys","isLoading","lastWidth","lastCollection","rootNodes","collator","invalidateEverything","constructor","options","getLayoutInfo","getVisibleLayoutInfos","res","addNodes","nodes","node","isVisible","validate","invalidationContext","buildCollection","y","layoutNode","rect","placeholder","layoutInfo","loader","buildChild","cached","childKeys","child","removeLayoutNode","buildNode","buildSection","width","rectHeight","isEstimated","previousLayoutNode","curNode","lastNode","headerRect","header","startY","children","buildItem","x","updateItemSize","size","newLayoutInfo","updateLayoutNode","n","getContentSize","getKeyAbove","key","item","getKeyBelow","getKeyPageAbove","pageY","Math","keyAbove","getKeyPageBelow","keyBelow","getFirstKey","getLastKey","getKeyForSearch","fromKey","substring","search","getInitialLayoutInfo","getFinalLayoutInfo","columnWidths","stickyColumnIndices","getDefaultWidth","c","body","buildColumnWidths","remainingColumns","remainingSpace","props","column","w","columnWidth","minWidth","maxWidth","parseWidth","match","parseInt","buildHeader","buildHeaderRow","row","headerRow","height","columns","setChildHeights","getColumnWidth","colspan","i","getEstimatedHeight","buildColumn","buildBody","empty","buildRow","buildCell","addVisibleLayoutInfos","firstVisibleRow","lastVisibleRow","firstVisibleCell","lastVisibleCell","stickyIndex","idx","binarySearch","low","high","items","mid","axis","point"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, KeyboardDelegate, Node} from '@react-types/shared';\nimport {InvalidationContext, Layout, LayoutInfo, Rect, Size} from '@react-stately/virtualizer';\nimport {Key} from 'react';\n// import { DragTarget, DropTarget, DropPosition } from '@react-types/shared';\n\nexport type ListLayoutOptions<T> = {\n  /** The height of a row in px. */\n  rowHeight?: number,\n  estimatedRowHeight?: number,\n  headingHeight?: number,\n  estimatedHeadingHeight?: number,\n  padding?: number,\n  indentationForItem?: (collection: Collection<Node<T>>, key: Key) => number,\n  collator?: Intl.Collator\n};\n\n// A wrapper around LayoutInfo that supports heirarchy\nexport interface LayoutNode {\n  node?: Node<unknown>,\n  layoutInfo: LayoutInfo,\n  header?: LayoutInfo,\n  children?: LayoutNode[]\n}\n\nconst DEFAULT_HEIGHT = 48;\n\n/**\n * The ListLayout class is an implementation of a collection view {@link Layout}\n * it is used for creating lists and lists with indented sub-lists.\n *\n * To configure a ListLayout, you can use the properties to define the\n * layouts and/or use the method for defining indentation.\n * The {@link ListKeyboardDelegate} extends the existing collection view\n * delegate with an additional method to do this (it uses the same delegate object as\n * the collection view itself).\n */\nexport class ListLayout<T> extends Layout<Node<T>> implements KeyboardDelegate {\n  protected rowHeight: number;\n  protected estimatedRowHeight: number;\n  protected headingHeight: number;\n  protected estimatedHeadingHeight: number;\n  protected padding: number;\n  protected indentationForItem?: (collection: Collection<Node<T>>, key: Key) => number;\n  protected layoutInfos: Map<Key, LayoutInfo>;\n  protected layoutNodes: Map<Key, LayoutNode>;\n  protected contentSize: Size;\n  collection: Collection<Node<T>>;\n  disabledKeys: Set<Key> = new Set();\n  isLoading: boolean;\n  protected lastWidth: number;\n  protected lastCollection: Collection<Node<T>>;\n  protected rootNodes: LayoutNode[];\n  protected collator: Intl.Collator;\n  protected invalidateEverything: boolean;\n\n  /**\n   * Creates a new ListLayout with options. See the list of properties below for a description\n   * of the options that can be provided.\n   */\n  constructor(options: ListLayoutOptions<T> = {}) {\n    super();\n    this.rowHeight = options.rowHeight;\n    this.estimatedRowHeight = options.estimatedRowHeight;\n    this.headingHeight = options.headingHeight;\n    this.estimatedHeadingHeight = options.estimatedHeadingHeight;\n    this.padding = options.padding || 0;\n    this.indentationForItem = options.indentationForItem;\n    this.collator = options.collator;\n    this.layoutInfos = new Map();\n    this.layoutNodes = new Map();\n    this.rootNodes = [];\n    this.lastWidth = 0;\n    this.lastCollection = null;\n  }\n\n  getLayoutInfo(key: Key) {\n    return this.layoutInfos.get(key);\n  }\n\n  getVisibleLayoutInfos(rect: Rect) {\n    let res: LayoutInfo[] = [];\n\n    let addNodes = (nodes: LayoutNode[]) => {\n      for (let node of nodes) {\n        if (this.isVisible(node, rect)) {\n          res.push(node.layoutInfo);\n          if (node.header) {\n            res.push(node.header);\n          }\n\n          if (node.children) {\n            addNodes(node.children);\n          }\n        }\n      }\n    };\n\n    addNodes(this.rootNodes);\n    return res;\n  }\n\n  isVisible(node: LayoutNode, rect: Rect) {\n    return node.layoutInfo.rect.intersects(rect) || node.layoutInfo.isSticky;\n  }\n\n  validate(invalidationContext: InvalidationContext<Node<T>, unknown>) {\n    // Invalidate cache if the size of the collection changed.\n    // In this case, we need to recalculate the entire layout.\n    this.invalidateEverything = invalidationContext.sizeChanged;\n\n    this.collection = this.virtualizer.collection;\n    this.rootNodes = this.buildCollection();\n\n    this.lastWidth = this.virtualizer.visibleRect.width;\n    this.lastCollection = this.collection;\n  }\n\n  buildCollection(): LayoutNode[] {\n    let y = this.padding;\n    let nodes = [];\n    for (let node of this.collection) {\n      let layoutNode = this.buildChild(node, 0, y);\n      y = layoutNode.layoutInfo.rect.maxY;\n      nodes.push(layoutNode);\n    }\n\n    if (nodes.length === 0) {\n      let rect = new Rect(0, y, this.virtualizer.visibleRect.width, this.rowHeight || this.estimatedRowHeight);\n      let placeholder = new LayoutInfo('placeholder', 'placeholder', rect);\n      this.layoutInfos.set('placeholder', placeholder);\n      nodes.push({layoutInfo: placeholder});\n      y = placeholder.rect.maxY;\n    }\n\n    if (this.isLoading) {\n      let rect = new Rect(0, y, this.virtualizer.visibleRect.width, 40);\n      let loader = new LayoutInfo('loader', 'loader', rect);\n      this.layoutInfos.set('loader', loader);\n      nodes.push({layoutInfo: loader});\n      y = loader.rect.maxY;\n    }\n\n    this.contentSize = new Size(this.virtualizer.visibleRect.width, y + this.padding);\n    return nodes;\n  }\n\n  buildChild(node: Node<T>, x: number, y: number): LayoutNode {\n    let cached = this.layoutNodes.get(node.key);\n    if (!this.invalidateEverything && cached && cached.node === node && y === (cached.header || cached.layoutInfo).rect.y) {\n      return cached;\n    }\n\n    let layoutNode = this.buildNode(node, x, y);\n    layoutNode.node = node;\n\n    layoutNode.layoutInfo.parentKey = node.parentKey || null;\n    this.layoutInfos.set(layoutNode.layoutInfo.key, layoutNode.layoutInfo);\n    if (layoutNode.header) {\n      this.layoutInfos.set(layoutNode.header.key, layoutNode.header);\n    }\n\n    // Remove deleted child layout nodes from key mapping.\n    if (cached) {\n      let childKeys = new Set();\n      if (layoutNode.children) {\n        for (let child of layoutNode.children) {\n          childKeys.add(child.layoutInfo.key);\n        }\n      }\n\n      if (cached.children) {\n        for (let child of cached.children) {\n          if (!childKeys.has(child.layoutInfo.key)) {\n            this.removeLayoutNode(child);\n          }\n        }\n      }\n    }\n\n    this.layoutNodes.set(node.key, layoutNode);\n    return layoutNode;\n  }\n\n  removeLayoutNode(layoutNode: LayoutNode) {\n    this.layoutNodes.delete(layoutNode.layoutInfo.key);\n\n    this.layoutInfos.delete(layoutNode.layoutInfo.key);\n    if (layoutNode.header) {\n      this.layoutInfos.delete(layoutNode.header.key);\n    }\n\n    if (layoutNode.children) {\n      for (let child of layoutNode.children) {\n        if (this.layoutNodes.get(child.layoutInfo.key) === child) {\n          this.removeLayoutNode(child);\n        }\n      }\n    }\n  }\n\n  buildNode(node: Node<T>, x: number, y: number): LayoutNode {\n    switch (node.type) {\n      case 'section':\n        return this.buildSection(node, x, y);\n      case 'item':\n        return this.buildItem(node, x, y);\n    }\n  }\n\n  buildSection(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.headingHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode && previousLayoutNode.header) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutNode.header.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.header.estimatedSize;\n      } else {\n        rectHeight = (node.rendered ? this.estimatedHeadingHeight : 0);\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    let headerRect = new Rect(0, y, width, rectHeight);\n    let header = new LayoutInfo('header', node.key + ':header', headerRect);\n    header.estimatedSize = isEstimated;\n    header.parentKey = node.key;\n    y += header.rect.height;\n\n    let rect = new Rect(0, y, width, 0);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n\n    let startY = y;\n    let children = [];\n    for (let child of node.childNodes) {\n      let layoutNode = this.buildChild(child, x, y);\n      y = layoutNode.layoutInfo.rect.maxY;\n      children.push(layoutNode);\n    }\n\n    rect.height = y - startY;\n\n    return {\n      header,\n      layoutInfo,\n      children\n    };\n  }\n\n  buildItem(node: Node<T>, x: number, y: number): LayoutNode {\n    let width = this.virtualizer.visibleRect.width;\n    let rectHeight = this.rowHeight;\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (rectHeight == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        rectHeight = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = width !== this.lastWidth || curNode !== lastNode || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        rectHeight = this.estimatedRowHeight;\n        isEstimated = true;\n      }\n    }\n\n    if (rectHeight == null) {\n      rectHeight = DEFAULT_HEIGHT;\n    }\n\n    if (typeof this.indentationForItem === 'function') {\n      x += this.indentationForItem(this.collection, node.key) || 0;\n    }\n\n    let rect = new Rect(x, y, width - x, rectHeight);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.estimatedSize = isEstimated;\n    return {\n      layoutInfo\n    };\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    let layoutInfo = this.layoutInfos.get(key);\n    layoutInfo.estimatedSize = false;\n    if (layoutInfo.rect.height !== size.height) {\n      // Copy layout info rather than mutating so that later caches are invalidated.\n      let newLayoutInfo = layoutInfo.copy();\n      newLayoutInfo.rect.height = size.height;\n      this.layoutInfos.set(key, newLayoutInfo);\n\n      // Invalidate layout for this layout node and all parents\n      this.updateLayoutNode(key, layoutInfo, newLayoutInfo);\n\n      let node = this.collection.getItem(layoutInfo.parentKey);\n      while (node) {\n        this.updateLayoutNode(node.key, layoutInfo, newLayoutInfo);\n        node = this.collection.getItem(node.parentKey);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  updateLayoutNode(key: Key, oldLayoutInfo: LayoutInfo, newLayoutInfo: LayoutInfo) {\n    let n = this.layoutNodes.get(key);\n    if (n) {\n      // Invalidate by clearing node.\n      n.node = null;\n\n      // Replace layout info in LayoutNode\n      if (n.header === oldLayoutInfo) {\n        n.header = newLayoutInfo;\n      } else if (n.layoutInfo === oldLayoutInfo) {\n        n.layoutInfo = newLayoutInfo;\n      }\n    }\n  }\n\n  getContentSize() {\n    return this.contentSize;\n  }\n\n  getKeyAbove(key: Key) {\n    let collection = this.collection;\n\n    key = collection.getKeyBefore(key);\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(item.key)) {\n        return key;\n      }\n\n      key = collection.getKeyBefore(key);\n    }\n  }\n\n  getKeyBelow(key: Key) {\n    let collection = this.collection;\n\n    key = collection.getKeyAfter(key);\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(item.key)) {\n        return key;\n      }\n\n      key = collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyPageAbove(key: Key) {\n    let layoutInfo = this.getLayoutInfo(key);\n\n    if (layoutInfo) {\n      let pageY = Math.max(0, layoutInfo.rect.y + layoutInfo.rect.height - this.virtualizer.visibleRect.height);\n      while (layoutInfo && layoutInfo.rect.y > pageY && layoutInfo) {\n        let keyAbove = this.getKeyAbove(layoutInfo.key);\n        layoutInfo = this.getLayoutInfo(keyAbove);\n      }\n\n      if (layoutInfo) {\n        return layoutInfo.key;\n      }\n    }\n\n    return this.getFirstKey();\n  }\n\n  getKeyPageBelow(key: Key) {\n    let layoutInfo = this.getLayoutInfo(key != null ? key : this.getFirstKey());\n\n    if (layoutInfo) {\n      let pageY = Math.min(this.virtualizer.contentSize.height, layoutInfo.rect.y - layoutInfo.rect.height + this.virtualizer.visibleRect.height);\n      while (layoutInfo && layoutInfo.rect.y < pageY) {\n        let keyBelow = this.getKeyBelow(layoutInfo.key);\n        layoutInfo = this.getLayoutInfo(keyBelow);\n      }\n\n      if (layoutInfo) {\n        return layoutInfo.key;\n      }\n    }\n\n    return this.getLastKey();\n  }\n\n  getFirstKey() {\n    let collection = this.collection;\n    let key = collection.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(item.key)) {\n        return key;\n      }\n\n      key = collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let collection = this.collection;\n    let key = collection.getLastKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(item.key)) {\n        return key;\n      }\n\n      key = collection.getKeyBefore(key);\n    }\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n\n  // getDragTarget(point: Point): DragTarget {\n  //   let visible = this.getVisibleLayoutInfos(new Rect(point.x, point.y, 1, 1));\n  //   if (visible.length > 0) {\n  //     visible = visible.sort((a, b) => b.zIndex - a.zIndex);\n  //     return {\n  //       type: 'item',\n  //       key: visible[0].key\n  //     };\n  //   }\n\n  //   return null;\n  // }\n\n  // getDropTarget(point: Point): DropTarget {\n  //   let key = this.virtualizer.keyAtPoint(point);\n  //   if (key) {\n  //     return {\n  //       type: 'item',\n  //       key,\n  //       dropPosition: DropPosition.ON\n  //     };\n  //   }\n\n  //   return null;\n  // }\n\n  getInitialLayoutInfo(layoutInfo: LayoutInfo) {\n    layoutInfo.opacity = 0;\n    layoutInfo.transform = 'scale3d(0.8, 0.8, 0.8)';\n    return layoutInfo;\n  }\n\n  getFinalLayoutInfo(layoutInfo: LayoutInfo) {\n    layoutInfo.opacity = 0;\n    layoutInfo.transform = 'scale3d(0.8, 0.8, 0.8)';\n    return layoutInfo;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {ColumnProps, TableCollection, TableNode} from '@react-types/table';\nimport {Key} from 'react';\nimport {LayoutInfo, Point, Rect, Size} from '@react-stately/virtualizer';\nimport {LayoutNode, ListLayout, ListLayoutOptions} from './ListLayout';\n\n\ntype TableLayoutOptions<T> = ListLayoutOptions<T> & {\n  getDefaultWidth: (props) => string | number\n}\n\nexport class TableLayout<T> extends ListLayout<T> {\n  collection: TableCollection<T>;\n  lastCollection: TableCollection<T>;\n  columnWidths: Map<Key, number>;\n  stickyColumnIndices: number[];\n  getDefaultWidth: (props) => string | number;\n\n  constructor(options: TableLayoutOptions<T>) {\n    super(options);\n    this.getDefaultWidth = options.getDefaultWidth;\n  }\n\n\n  buildCollection(): LayoutNode[] {\n    // If columns changed, clear layout cache.\n    if (\n      !this.lastCollection ||\n      this.collection.columns.length !== this.lastCollection.columns.length ||\n      this.collection.columns.some((c, i) => c.key !== this.lastCollection.columns[i].key)\n    ) {\n      // Invalidate everything in this layout pass. Will be reset in ListLayout on the next pass.\n      this.invalidateEverything = true;\n    }\n\n    this.buildColumnWidths();\n    let header = this.buildHeader();\n    let body = this.buildBody(0);\n    body.layoutInfo.rect.width = Math.max(header.layoutInfo.rect.width, body.layoutInfo.rect.width);\n    this.contentSize = new Size(body.layoutInfo.rect.width, body.layoutInfo.rect.maxY);\n    return [\n      header,\n      body\n    ];\n  }\n\n  buildColumnWidths() {\n    this.columnWidths = new Map();\n    this.stickyColumnIndices = [];\n\n    // Pass 1: set widths for all explicitly defined columns.\n    let remainingColumns = new Set<TableNode<T>>();\n    let remainingSpace = this.virtualizer.visibleRect.width;\n    for (let column of this.collection.columns) {\n      let props = column.props as ColumnProps<T>;\n      let width = props.width ?? props.defaultWidth ?? this.getDefaultWidth(props);\n      if (width != null) {\n        let w = this.parseWidth(width);\n        this.columnWidths.set(column.key, w);\n        remainingSpace -= w;\n      } else {\n        remainingColumns.add(column);\n      }\n\n      // The selection cell and any other sticky columns always need to be visible.\n      // In addition, row headers need to be in the DOM for accessibility labeling.\n      if (column.props.isSelectionCell || this.collection.rowHeaderColumnKeys.has(column.key)) {\n        this.stickyColumnIndices.push(column.index);\n      }\n    }\n\n    // Pass 2: if there are remaining columns, then distribute the remaining space evenly.\n    if (remainingColumns.size > 0) {\n      let columnWidth = remainingSpace / (this.collection.columns.length - this.columnWidths.size);\n\n      for (let column of remainingColumns) {\n        let props = column.props as ColumnProps<T>;\n        let minWidth = props.minWidth != null ? this.parseWidth(props.minWidth) : 75;\n        let maxWidth = props.maxWidth != null ? this.parseWidth(props.maxWidth) : Infinity;\n        let width = Math.max(minWidth, Math.min(maxWidth, columnWidth));\n\n        this.columnWidths.set(column.key, width);\n        remainingSpace -= width;\n        if (width !== columnWidth) {\n          columnWidth = remainingSpace / (this.collection.columns.length - this.columnWidths.size);\n        }\n      }\n    }\n  }\n\n  parseWidth(width: number | string): number {\n    if (typeof width === 'string') {\n      let match = width.match(/^(\\d+)%$/);\n      if (!match) {\n        throw new Error('Only percentages are supported as column widths');\n      }\n\n      return this.virtualizer.visibleRect.width * (parseInt(match[1], 10) / 100);\n    }\n\n    return width;\n  }\n\n  buildHeader(): LayoutNode {\n    let rect = new Rect(0, 0, 0, 0);\n    let layoutInfo = new LayoutInfo('header', 'header', rect);\n\n    let y = 0;\n    let width = 0;\n    let children: LayoutNode[] = [];\n    for (let headerRow of this.collection.headerRows) {\n      let layoutNode = this.buildChild(headerRow, 0, y);\n      layoutNode.layoutInfo.parentKey = 'header';\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      children.push(layoutNode);\n    }\n\n    rect.width = width;\n    rect.height = y;\n\n    this.layoutInfos.set('header', layoutInfo);\n\n    return {\n      layoutInfo,\n      children\n    };\n  }\n\n  buildHeaderRow(headerRow: TableNode<T>, x: number, y: number) {\n    let rect = new Rect(0, y, 0, 0);\n    let row = new LayoutInfo('headerrow', headerRow.key, rect);\n\n    let height = 0;\n    let columns: LayoutNode[] = [];\n    for (let cell of headerRow.childNodes) {\n      let layoutNode = this.buildChild(cell, x, y);\n      layoutNode.layoutInfo.parentKey = row.key;\n      x = layoutNode.layoutInfo.rect.maxX;\n      height = Math.max(height, layoutNode.layoutInfo.rect.height);\n      columns.push(layoutNode);\n    }\n\n    this.setChildHeights(columns, height);\n\n    rect.height = height;\n    rect.width = x;\n\n    return {\n      layoutInfo: row,\n      children: columns\n    };\n  }\n\n  setChildHeights(children: LayoutNode[], height: number) {\n    for (let child of children) {\n      if (child.layoutInfo.rect.height !== height) {\n        // Need to copy the layout info before we mutate it.\n        child.layoutInfo = child.layoutInfo.copy();\n        this.layoutInfos.set(child.layoutInfo.key, child.layoutInfo);\n\n        child.layoutInfo.rect.height = height;\n      }\n    }\n  }\n\n  getColumnWidth(node: TableNode<T>) {\n    let colspan = node.colspan ?? 1;\n    let width = 0;\n    for (let i = 0; i < colspan; i++) {\n      let column = this.collection.columns[node.index + i];\n      width += this.columnWidths.get(column.key);\n    }\n\n    return width;\n  }\n\n  getEstimatedHeight(node: TableNode<T>, width: number, height: number, estimatedHeight: number) {\n    let isEstimated = false;\n\n    // If no explicit height is available, use an estimated height.\n    if (height == null) {\n      // If a previous version of this layout info exists, reuse its height.\n      // Mark as estimated if the size of the overall collection view changed,\n      // or the content of the item changed.\n      let previousLayoutNode = this.layoutNodes.get(node.key);\n      if (previousLayoutNode) {\n        let curNode = this.collection.getItem(node.key);\n        let lastNode = this.lastCollection ? this.lastCollection.getItem(node.key) : null;\n        height = previousLayoutNode.layoutInfo.rect.height;\n        isEstimated = curNode !== lastNode || width !== previousLayoutNode.layoutInfo.rect.width || previousLayoutNode.layoutInfo.estimatedSize;\n      } else {\n        height = estimatedHeight;\n        isEstimated = true;\n      }\n    }\n\n    return {height, isEstimated};\n  }\n\n  buildColumn(node: TableNode<T>, x: number, y: number): LayoutNode {\n    let width = this.getColumnWidth(node);\n    let {height, isEstimated} = this.getEstimatedHeight(node, width, this.headingHeight, this.estimatedHeadingHeight);\n    let rect = new Rect(x, y, width, height);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = node.props?.isSelectionCell;\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n\n    return {\n      layoutInfo\n    };\n  }\n\n  buildBody(y: number): LayoutNode {\n    let rect = new Rect(0, y, 0, 0);\n    let layoutInfo = new LayoutInfo('rowgroup', 'body', rect);\n\n    let startY = y;\n    let width = 0;\n    let children: LayoutNode[] = [];\n    for (let node of this.collection.body.childNodes) {\n      let layoutNode = this.buildChild(node, 0, y);\n      layoutNode.layoutInfo.parentKey = 'body';\n      y = layoutNode.layoutInfo.rect.maxY;\n      width = Math.max(width, layoutNode.layoutInfo.rect.width);\n      children.push(layoutNode);\n    }\n\n    // TODO: not show the spinner at the bottom when sorting?\n    if (this.collection.body.props.isLoading) {\n      let rect = new Rect(0, y, width || this.virtualizer.visibleRect.width, children.length === 0 ? this.virtualizer.visibleRect.height : 60);\n      let loader = new LayoutInfo('loader', 'loader', rect);\n      loader.parentKey = 'body';\n      loader.isSticky = children.length === 0;\n      this.layoutInfos.set('loader', loader);\n      children.push({layoutInfo: loader});\n      y = loader.rect.maxY;\n      width = Math.max(width, rect.width);\n    } else if (children.length === 0) {\n      let rect = new Rect(0, y, this.virtualizer.visibleRect.width, this.virtualizer.visibleRect.height);\n      let empty = new LayoutInfo('empty', 'empty', rect);\n      empty.parentKey = 'body';\n      empty.isSticky = true;\n      this.layoutInfos.set('empty', empty);\n      children.push({layoutInfo: empty});\n      y = empty.rect.maxY;\n      width = Math.max(width, rect.width);\n    }\n\n    rect.width = width;\n    rect.height = y - startY;\n\n    this.layoutInfos.set('body', layoutInfo);\n\n    return {\n      layoutInfo,\n      children\n    };\n  }\n\n  buildNode(node: TableNode<T>, x: number, y: number): LayoutNode {\n    switch (node.type) {\n      case 'headerrow':\n        return this.buildHeaderRow(node, x, y);\n      case 'item':\n        return this.buildRow(node, x, y);\n      case 'column':\n      case 'placeholder':\n        return this.buildColumn(node, x, y);\n      case 'cell':\n        return this.buildCell(node, x, y);\n      default:\n        throw new Error('Unknown node type ' + node.type);\n    }\n  }\n\n  buildRow(node: TableNode<T>, x: number, y: number): LayoutNode {\n    let rect = new Rect(x, y, 0, 0);\n    let layoutInfo = new LayoutInfo('row', node.key, rect);\n\n    let children: LayoutNode[] = [];\n    let height = 0;\n    for (let child of node.childNodes) {\n      let layoutNode = this.buildChild(child, x, y);\n      x = layoutNode.layoutInfo.rect.maxX;\n      height = Math.max(height, layoutNode.layoutInfo.rect.height);\n      children.push(layoutNode);\n    }\n\n    this.setChildHeights(children, height);\n\n    rect.width = x;\n    rect.height = height + 1; // +1 for bottom border\n\n    return {\n      layoutInfo,\n      children\n    };\n  }\n\n  buildCell(node: TableNode<T>, x: number, y: number): LayoutNode {\n    let width = this.getColumnWidth(node);\n    let {height, isEstimated} = this.getEstimatedHeight(node, width, this.rowHeight, this.estimatedRowHeight);\n    let rect = new Rect(x, y, width, height);\n    let layoutInfo = new LayoutInfo(node.type, node.key, rect);\n    layoutInfo.isSticky = node.props?.isSelectionCell;\n    layoutInfo.zIndex = layoutInfo.isSticky ? 2 : 1;\n    layoutInfo.estimatedSize = isEstimated;\n\n    return {\n      layoutInfo\n    };\n  }\n\n  getVisibleLayoutInfos(rect: Rect) {\n    let res: LayoutInfo[] = [];\n\n    for (let node of this.rootNodes) {\n      res.push(node.layoutInfo);\n      this.addVisibleLayoutInfos(res, node, rect);\n    }\n\n    return res;\n  }\n\n  addVisibleLayoutInfos(res: LayoutInfo[], node: LayoutNode, rect: Rect) {\n    if (!node.children || node.children.length === 0) {\n      return;\n    }\n\n    switch (node.layoutInfo.type) {\n      case 'header': {\n        for (let child of node.children) {\n          res.push(child.layoutInfo);\n          this.addVisibleLayoutInfos(res, child, rect);\n        }\n        break;\n      }\n      case 'rowgroup': {\n        let firstVisibleRow = this.binarySearch(node.children, rect.topLeft, 'y');\n        let lastVisibleRow = this.binarySearch(node.children, rect.bottomRight, 'y');\n        for (let i = firstVisibleRow; i <= lastVisibleRow; i++) {\n          res.push(node.children[i].layoutInfo);\n          this.addVisibleLayoutInfos(res, node.children[i], rect);\n        }\n        break;\n      }\n      case 'headerrow':\n      case 'row': {\n        let firstVisibleCell = this.binarySearch(node.children, rect.topLeft, 'x');\n        let lastVisibleCell = this.binarySearch(node.children, rect.topRight, 'x');\n        let stickyIndex = 0;\n        for (let i = firstVisibleCell; i <= lastVisibleCell; i++) {\n          // Sticky columns and row headers are always in the DOM. Interleave these\n          // with the visible range so that they are in the right order.\n          if (stickyIndex < this.stickyColumnIndices.length) {\n            let idx = this.stickyColumnIndices[stickyIndex];\n            while (idx < i) {\n              res.push(node.children[idx].layoutInfo);\n              idx = this.stickyColumnIndices[stickyIndex++];\n            }\n          }\n\n          res.push(node.children[i].layoutInfo);\n        }\n\n        while (stickyIndex < this.stickyColumnIndices.length) {\n          let idx = this.stickyColumnIndices[stickyIndex++];\n          res.push(node.children[idx].layoutInfo);\n        }\n        break;\n      }\n      default:\n        throw new Error('Unknown node type ' + node.layoutInfo.type);\n    }\n  }\n\n  binarySearch(items: LayoutNode[], point: Point, axis: 'x' | 'y') {\n    let low = 0;\n    let high = items.length - 1;\n    while (low <= high) {\n      let mid = (low + high) >> 1;\n      let item = items[mid];\n\n      if ((axis === 'x' && item.layoutInfo.rect.maxX < point.x) || (axis === 'y' && item.layoutInfo.rect.maxY < point.y)) {\n        low = mid + 1;\n      } else if ((axis === 'x' && item.layoutInfo.rect.x > point.x) || (axis === 'y' && item.layoutInfo.rect.y > point.y)) {\n        high = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return Math.max(0, Math.min(items.length - 1, low));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}